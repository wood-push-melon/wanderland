{"pages":[{"title":"tags","text":"","link":"/wanderland/tags/index.html"},{"title":"categories","text":"","link":"/wanderland/categories/index.html"}],"posts":[{"title":"Two Sum IV - Input is a BST","text":"ProblemGiven a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target. Example 1: 12345678910Input: 5 / \\ 3 6 / \\ \\2 4 7Target = 9Output: True Example 2: 12345678910Input: 5 / \\ 3 6 / \\ \\2 4 7Target = 28Output: False SolutionsThe solution to this problem is sort of similar to the one in the original Two Sum problem.The only difference is to traversing a Tree instead of an Array. We use BFS to iterate the whole structure, but DFS is completely a feasible alternative too. 12345678910111213141516171819def findTarget(root: 'TreeNode', k: 'int') -&gt; 'bool': if root is None: return False cache = set() queue = [root] while queue: node = queue.pop(0) if k - node.val in cache: return True cache.add(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return False","link":"/wanderland/2019/02/12/2sum-bst/"},{"title":"3 Sum Closest","text":"ProblemGiven an array nums of n integers and in interger target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example: 123Given array nums = [-1, 2, 1, -4], and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2) SolutionThe solution to this problem is adapted from the solution in 3 Sum, applying the two pointers strategy. Adaptations are straightforward. NOTE: Initially the closest sum should be given a starting value for comparison inside the loop later. Here we start it with the sum of first three elements, which is the minimum sum among all three-element combinations after soring the input array. However, what the closest initially is does not matter. 1234567891011121314151617181920212223242526272829303132333435363738394041def three_sum_closest(nums, target): n = len(nums) if n &lt; 3: return nums.sort() # initialize closest sum closest = nums[0] + nums[1] + nums[2] for i in range(n-2): l , r = i + 1, n - 1 while l &lt; r: s = nums[0] + nums[1] + nums[2] if s == target: return s if abs(s-target) &lt; abs(closest-target): closest = s if s &lt; target: l = increment(nums, l, r) else: r = decrement(nums, l, r) return closestdef increment(nums, l, r): while l &lt; r and nums[l] == nums[l+1]: l += 1 return l + 1def decrement(nums, l, r): while l &lt; r and nums[r] == nums[r-1]: r -= 1 return r - 1","link":"/wanderland/2019/02/18/3sum-closest/"},{"title":"3 Sum","text":"ProblemGiven an array nums of n integers, are there three elements a, b, c in nums such that a + b + c = 0 ? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: 1234567Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] SolutionTwo pointers strategy comes to help again. We can first sort the input array, and then make use of the solution in 2 sum with sorted input array to solve this 3 sum problem when we fix the first element a. NOTE The problem specifies that no duplicate driplets should appear in the result, so we have to take this in mind. To meet this requirement, moving left and right pointers should be more aggressive, like skipping next element with same value. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647def three_sum(nums: 'List[int]') -&gt; 'List[List[int]]': res = [] n = len(nums) if n &lt; 3: return res nums.sort() # sort the input first for i in range(n-2): # no need to move on if the fixed element is greater than 0 if nums[i] &gt; 0: break # skip elements with same value if i &gt; 0 and nums[i] == nums[i-1]: continue l, r = i + 1, n - 1 while l &lt; r: s = nums[i] + nums[l] + nums[r] if s == 0: res.append([nums[i], nums[l], nums[r]]) l = increment(nums, l, r) r = decrement(nums, l, r) elif s &lt; 0: l = increment(nums, l, r) else: r = decrement(nums, l, r) return res# increment pointer by skipping same-value elementsdef increment(nums, l, r): while l &lt; r and nums[l] == nums[l+1]: l += 1 return l + 1# decrement pointer by skipping same-value elementsdef decrement(nums, l, r): while l &lt; r and nums[r] == nums[r-1]: r -= 1 return r - 1","link":"/wanderland/2019/02/16/3sum/"},{"title":"Two Sum II - Input array is sorted","text":"ProblemGiven an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Note: Your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. Example: 12345Input: numbers = [2,7,11,15], target = 9Output: [1,2]Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2. SolutionsThe key point is to take advantage of sorted array. We can use two pointers strategy or binary search method to solve this problem. Two solutions are shown below respectively. Solution with two pointers is relatively easy to catch, and it should be the first answer you provide in an interview. Two pointer solution: 123456789101112# Solution with two pointersdef twoSum(nums: 'List[int]', target: 'int') -&gt; 'List[int]': lo, hi = 0, len(nums) - 1 while lo &lt; hi: s = nums[lo] + nums[hi] if s == target: return [lo+1, hi+1] elif s &lt; target: lo += 1 else: hi -= 1 Binary search solution: Binary search solution is kind of difficult to understant compared with two pointer one. Basically it uses binary search algorithm to move start or end pointer faster rather than one step in each iteration. It tries to move start to a new position where nums[start] is the first value that nums[start] &gt;= target - nums[end] if the sum is less than target. Similar logic applies to end pointer. In each helper function, we only consider the pointer we care about. 123456789101112131415161718192021222324252627282930313233343536373839404142434445# Solution using binary searchdef twoSum(nums: 'List[int]', target: 'int') -&gt; 'List[int]': start, end = 0, len(nums) - 1 while start &lt; end: s = nums[start] + nums[end] if s == target: return [start+1, end+1] elif s &lt; target: # need to adjust start pointer start = binary_search_start(nums, start, end, target-nums[end]) else: # need to adjust end pointer end = binary_search_end(nums, start, end, target-nums[start])def binary_search_start(nums, start, end, key): ''' Move the start pointer to the position where nums[start] is the first element greater than or equal to the key ''' while start &lt;= end: mid = start + (end - start) // 2 if nums[mid] &lt; key: start = mid + 1 else: end = mid - 1 return startdef binary_search_end(nums, start, end, key): ''' Move the end pointer to the position where nums[end] is the last element less than or equal to the key ''' while start &lt;= end: mid = start + (end - start) // 2 if nums[mid] &gt; key: end = mid - 1 else: start = mid + 1 return end","link":"/wanderland/2019/02/10/2sum-sorted/"},{"title":"2Sum","text":"ProblemGiven an array of integers, return indices of the two numbers such that they add up to specific target.You may assume that each inpjut would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. SolutionThe key to this problem is using an external hashtable-like data structure to store the iterated element and its idex in the array, and use such storage to see if the counterpart is already in there. NOTE If the length of nums is less than 2, it is not necessary to go ahead It is better to maintain the order in result list 12345678910def two_sum(nums: 'List[int]', target: 'int') -&gt; 'List[int]': if len(nums) &lt; 2: return cache = {} for idx, num in enumerate(nums): if target - num in cache: return [cache.get(target-num), idx] else: cache.update({num: idx})","link":"/wanderland/2019/02/09/2sum/"},{"title":"Palindrome Number","text":"ProblemDetermine whether an integer is a palindrome. An integer is palindrome when it reads the same backward as forward. Example: 12Input: 121Output: true Example: 123Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. SolutionThe first solution coming intuitively is to convert the input to string, and then easily compare the str(input) with reverse(str(input)). NOTE As for Python, we don’t have the risk of being overflowed for int type, since the memory is allocated dynamically. The int object could be infinitely large theoretically. 12def is_palindrome(x: int) -&gt; bool: return str(x) == str(x)[::-1] The second way to address this problem is just following pure math. 12345678910def is_palindrome(x: int) -&gt; bool: if x &lt; 0: return False rev, tmp = 0, x while tmp: rev = rev * 10 + tmp % 10 tmp = tmp // 10 return rev == x","link":"/wanderland/2019/03/08/palindrome-number/"},{"title":"Add Two Numbers","text":"ProblemYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. Example: 123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807 SolutionsAt the first glance, we need to solve this problem with regular way in math, adding digits at the same position one by one. However, the edge case is that the resulting list may have carry bit. Sentinel strategy is also applied in here. 123456789101112131415161718192021222324class ListNode: def ___init___(self, x): self.val = x self.next = Nonedef add_two_numbers(l1: ListNode, l2: ListNode) -&gt; ListNode: dummy = curr = ListNode(0) carry = 0 while l1 or l2 or carry: if l1: carry += l1.val l1 = l1.next if l2: carry += l2.val l2 = l2.next curr.next = ListNode(carry % 10) curr = curr.next carry //= 10 return dummy.next","link":"/wanderland/2019/05/23/add-two-numbers/"},{"title":"4 Sum","text":"ProblemGiven an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b +c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. Example: 12345678Given array nums = [1, 0, -1, 0, -2, 2], and target = 0A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] SolutionThe solution to k-sum can always be decomopsed to 2-sum problem with k-2 loops wrapping. With this strategic template in mind, we can boil down 4-sum problem to the following implementation. 1234567891011121314151617181920212223242526272829303132333435363738394041424344def four_sum(nums: 'List[int]', target: 'int') -&gt; 'List[List[int]]': res = [] n = len(nums) if n &lt; 4: return res nums.sort() for i in range(n-3): if i &gt; 0 and nums[i] == nums[i-1]: continue for j in range(n-2): if j &gt; i+1 and nums[j] == nums[j-1]: continue l, r = j + 1, n - 1 while l &lt; r: s = nums[i] + nums[j] + nums[l] + nums[r] if s == target: res.append([nums[i], nums[j], nums[l], nums[r]) l = increment(nums, l, r) r = decrement(nums, l, r) elif s &lt; target: l = increment(nums, l, r) else: r = decrement(nums, l, r) return resdef increment(nums, l, r): while l &lt; r and nums[l] == nums[l+1]: l += 1 return l + 1def decrement(nums, l, r): while l &lt; r and nums[r] == nums[r-1]: r -= 1 return r - 1 NOTEk-sum problem can be implemented by using recursion. We will add such implementation later.","link":"/wanderland/2019/02/20/4sum/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/wanderland/2018/12/29/hello-world/"},{"title":"Power of Two","text":"ProblemGiven an integer, write a function to determine if it is a power of two. Example: 123Input: 1Output: trueExplanation: 2^0 = 1 Example: 123Input: 16Output: trueExplanation: 2^4 = 16 SolutionWe of course can follow the intuitive way to judge if the input is a power of two. But LeetCode gave me a 「Time Limit Exceeded」… Anyway, this method also suits Power of Three and Power of Four. 12345678def is_power_of_two(n: int) -&gt; bool: if n &lt;= 0: return False while not n % 2: n = n // 2 return n == 1 Another try goes to recursion. 12def is_power_of_two(n: int) -&gt; bool: return n &gt; 0 and ( n == 1 or ( n % 2 == 0 and isPowerOfTwo(n//2) ) ) Bit manipulation solution is a little bit tricky at first glance. it works based on the fact that n &amp; (n-1) == 0 if n is a power of two. Example: 123a = 16 which is 0b10000b = 15 which is 0b01111a &amp; b = 0 12345def is_power_of_two(n: int) -&gt; bool: if n &lt;= 0: return False return not (n &amp; (n-1) )","link":"/wanderland/2019/03/08/power-of-two/"},{"title":"Learning Materials","text":"System Design Grokking the System Design Interview","link":"/wanderland/2019/04/14/learn-resource/"},{"title":"Sorting Algorithms","text":"This post is aim to summerize a handful of fundamental sorting algoritms that one should be very familiar with. Bubble SortIt compares adjacent two elements in the input array to check if a swap is needed. The right half section is sorted.Time complexity is O(n^2).It is stable. 1234567891011121314def bubble_sort(seq): n = len(seq) if n &lt; 2 return for i in range(n): flag = False for j in range(n - i - 1): if seq[j] &gt; seq[j+1]: seq[j], seq[j+1] = seq[j+1], seq[j] flag = True if flag is False: break Insertion SortIt divides the input sequence into two parts: sorted and unsorted sections. Unsorted section starts from i to the end.It compares the first element seq[i] in unsorted section with element seq[j] in sorted part in reverse order step by step by moving sorted elements until a proper location is found.Time complexity is O(n^2).It is stable. 12345678910111213def insertion_sort(seq): n = len(seq) if n &lt; 2 return for i in range(1, n): value = seq[i] j = i - 1 while j &gt;= 0 and seq[j] &gt; value: seq[j+1] = seq[j] j -= 1 seq[j+1] = value Selection SortSimilarly, it divides the input into sorted and unsorted parts. It picks minimum value seq[min_idx] at each iteration to swap with head element seq[i] in the unsorted section.Time complexity is O(n^2).It is NOT stable. 12345678910111213def selection_sort(seq): n = len(seq) if n &lt; 2: return for i in range(n): min_idx = i for j in range(i+1, n): if seq[j] &lt; seq[min_idx]: min_idx = j if min_idx != i: seq[i], seq[min_idx] = seq[min_idx], seq[i] Merge SortIt at the beginning divides the input array recursively, and later rebuild it by merging two parts in ascending order. The merge implementation is the hinge.Time complexity is O(nlogn).It is stable. Recursion equation:1234merge_sort(l...r) = merge(merge_sort(l...m), merge(m+1...r))it terminates when:l &gt;= r 123456789101112131415161718192021222324252627282930def merge_sort(seq): sort(seq, 0, len(seq)-1)def sort(seq, l, r): if l &gt;= r: return m = l + (r - l) // 2 sort(seq, l, m) sort(seq, m+1, r) merge(seq, l, m, r)def merge(seq, l, m, r): i, j = l, m+1 tmp = [] while i &lt;= m and j &lt;= r: if seq[i] &lt;= seq[j]: tmp.append(seq[i]) i += 1 else: tmp.append(seq[j]) j += 1 start = i if i &lt;= m else j end = m if i &lt;= m else r tmp.extend(seq[start:end]) seq[:] = tmp Quick SortThe key is all about partition implementation. It picks the last element as pivot to make sure all elements before the pivot are less than it, and elements after it are greater.Time complexity is O(nlogn).It is NOT stable. Recursion equation:1234quick_sort(l...r) = quick_sort(l...p-1) + quick_sort(p+1...r)it terminates when:l &gt;= r 123456789101112131415161718192021222324def quick_sort(seq): sort(seq, 0, len(seq) - 1)def sort(seq, l, r): if l &gt;= r: return pivot = partition(seq, l, r) sort(seq, l, pivot-1) sort(seq, pivot+1, r)def partition(seq, l, r): pivot = seq[r] i = l for j in range(l, r): if seq[j] &lt; pivot: seq[i], seq[j] = seq[j], seq[i] i += 1 seq[i], seq[r] = seq[r], seq[i] return i Heap SortHeap Sort continuously swaps the top element (the maximum) with the last element in the heap, and build the heap again.Time complexity is O(nlogn).It is NOT stable. 12345678910111213141516171819202122232425262728293031323334353637def heap_sort(seq): build_heap(seq) heap_size = len(seq) - 1 for last in range(heap_size, 0, -1): seq[0], seq[last] = seq[last], seq[0] heap_size -= 1 heapify(seq, 0, heap_size) return seqdef build_heap(seq): ''' Only necessary to build heap from 0 to n // 2 because leaf nodes start from n // 2 + 1 ''' n = len(seq) - 1 for i in range(n // 2, -1, -1): heapify(seq, i, n)def heapify(seq, i, n): while True: l, r = 2 * i + 1, 2 * i + 2 max_idx = i if l &lt;= n and seq[i] &lt; seq[l]: max_idx = l if r &lt;= n and seq[max_idx] &lt; seq[r]: max_idx = r if max_idx == i: break seq[i], seq[max_idx] = seq[max_idx], seq[i] i = max_idx SummaryMerge Sort and Quick Sort are based on Divide and Conquer strategy. They are capable of sorting large-scale data, while others left are supposed to sort data in musch smaller size. Even though having the same time complexity, Heap Sort is not superior to Quick Sort. Heap Sort needs more swap processes, and heapify procedure does not access data in the array sequentially, unfriendly to CPU cache.","link":"/wanderland/2019/02/14/sorting/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","link":"/wanderland/tags/LeetCode/"},{"name":"Array","slug":"Array","link":"/wanderland/tags/Array/"},{"name":"Hash Table","slug":"Hash-Table","link":"/wanderland/tags/Hash-Table/"},{"name":"Tree","slug":"Tree","link":"/wanderland/tags/Tree/"},{"name":"Two Pointers","slug":"Two-Pointers","link":"/wanderland/tags/Two-Pointers/"},{"name":"Binary Search","slug":"Binary-Search","link":"/wanderland/tags/Binary-Search/"},{"name":"Math","slug":"Math","link":"/wanderland/tags/Math/"},{"name":"Linked List","slug":"Linked-List","link":"/wanderland/tags/Linked-List/"},{"name":"Sentinel","slug":"Sentinel","link":"/wanderland/tags/Sentinel/"},{"name":"Big Manipulation","slug":"Big-Manipulation","link":"/wanderland/tags/Big-Manipulation/"},{"name":"Learn","slug":"Learn","link":"/wanderland/tags/Learn/"},{"name":"Algorithms","slug":"Algorithms","link":"/wanderland/tags/Algorithms/"},{"name":"Sorting","slug":"Sorting","link":"/wanderland/tags/Sorting/"}],"categories":[]}