{"pages":[{"title":"tags","text":"","link":"/wanderland/tags/index.html"},{"title":"categories","text":"","link":"/wanderland/categories/index.html"}],"posts":[{"title":"Two Sum IV - Input is a BST","text":"ProblemGiven a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target. Example 1: 12345678910Input: 5 / \\ 3 6 / \\ \\2 4 7Target = 9Output: True Example 2: 12345678910Input: 5 / \\ 3 6 / \\ \\2 4 7Target = 28Output: False SolutionsThe solution to this problem is sort of similar to the one in the original Two Sum problem.The only difference is to traversing a Tree instead of an Array. We use BFS to iterate the whole structure, but DFS is completely a feasible alternative too. 12345678910111213141516171819def findTarget(root: 'TreeNode', k: 'int') -&gt; 'bool': if root is None: return False cache = set() queue = [root] while queue: node = queue.pop(0) if k - node.val in cache: return True cache.add(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return False","link":"/wanderland/2019/02/12/2sum-bst/"},{"title":"3 Sum Closest","text":"ProblemGiven an array nums of n integers and in interger target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example: 123Given array nums = [-1, 2, 1, -4], and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2) SolutionThe solution to this problem is adapted from the solution in 3 Sum, applying the two pointers strategy. Adaptations are straightforward. NOTE: Initially the closest sum should be given a starting value for comparison inside the loop later. Here we start it with the sum of first three elements, which is the minimum sum among all three-element combinations after soring the input array. However, what the closest initially is does not matter. 1234567891011121314151617181920212223242526272829303132333435363738394041def three_sum_closest(nums, target): n = len(nums) if n &lt; 3: return nums.sort() # initialize closest sum closest = nums[0] + nums[1] + nums[2] for i in range(n-2): l , r = i + 1, n - 1 while l &lt; r: s = nums[0] + nums[1] + nums[2] if s == target: return s if abs(s-target) &lt; abs(closest-target): closest = s if s &lt; target: l = increment(nums, l, r) else: r = decrement(nums, l, r) return closestdef increment(nums, l, r): while l &lt; r and nums[l] == nums[l+1]: l += 1 return l + 1def decrement(nums, l, r): while l &lt; r and nums[r] == nums[r-1]: r -= 1 return r - 1","link":"/wanderland/2019/02/18/3sum-closest/"},{"title":"3 Sum","text":"ProblemGiven an array nums of n integers, are there three elements a, b, c in nums such that a + b + c = 0 ? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: 1234567Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] SolutionTwo pointers strategy comes to help again. We can first sort the input array, and then make use of the solution in 2 sum with sorted input array to solve this 3 sum problem when we fix the first element a. NOTE The problem specifies that no duplicate driplets should appear in the result, so we have to take this in mind. To meet this requirement, moving left and right pointers should be more aggressive, like skipping next element with same value. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647def three_sum(nums: 'List[int]') -&gt; 'List[List[int]]': res = [] n = len(nums) if n &lt; 3: return res nums.sort() # sort the input first for i in range(n-2): # no need to move on if the fixed element is greater than 0 if nums[i] &gt; 0: break # skip elements with same value if i &gt; 0 and nums[i] == nums[i-1]: continue l, r = i + 1, n - 1 while l &lt; r: s = nums[i] + nums[l] + nums[r] if s == 0: res.append([nums[i], nums[l], nums[r]]) l = increment(nums, l, r) r = decrement(nums, l, r) elif s &lt; 0: l = increment(nums, l, r) else: r = decrement(nums, l, r) return res# increment pointer by skipping same-value elementsdef increment(nums, l, r): while l &lt; r and nums[l] == nums[l+1]: l += 1 return l + 1# decrement pointer by skipping same-value elementsdef decrement(nums, l, r): while l &lt; r and nums[r] == nums[r-1]: r -= 1 return r - 1","link":"/wanderland/2019/02/16/3sum/"},{"title":"2Sum","text":"ProblemGiven an array of integers, return indices of the two numbers such that they add up to specific target.You may assume that each inpjut would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. SolutionThe key to this problem is using an external hashtable-like data structure to store the iterated element and its idex in the array, and use such storage to see if the counterpart is already in there. NOTE If the length of nums is less than 2, it is not necessary to go ahead It is better to maintain the order in result list 12345678910def two_sum(nums: 'List[int]', target: 'int') -&gt; 'List[int]': if len(nums) &lt; 2: return cache = {} for idx, num in enumerate(nums): if target - num in cache: return [cache.get(target-num), idx] else: cache.update({num: idx})","link":"/wanderland/2019/02/09/2sum/"},{"title":"4 Sum","text":"ProblemGiven an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b +c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. Example: 12345678Given array nums = [1, 0, -1, 0, -2, 2], and target = 0A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] SolutionThe solution to k-sum can always be decomopsed to 2-sum problem with k-2 loops wrapping. With this strategic template in mind, we can boil down 4-sum problem to the following implementation. 1234567891011121314151617181920212223242526272829303132333435363738394041424344def four_sum(nums: 'List[int]', target: 'int') -&gt; 'List[List[int]]': res = [] n = len(nums) if n &lt; 4: return res nums.sort() for i in range(n-3): if i &gt; 0 and nums[i] == nums[i-1]: continue for j in range(n-2): if j &gt; i+1 and nums[j] == nums[j-1]: continue l, r = j + 1, n - 1 while l &lt; r: s = nums[i] + nums[j] + nums[l] + nums[r] if s == target: res.append([nums[i], nums[j], nums[l], nums[r]) l = increment(nums, l, r) r = decrement(nums, l, r) elif s &lt; target: l = increment(nums, l, r) else: r = decrement(nums, l, r) return resdef increment(nums, l, r): while l &lt; r and nums[l] == nums[l+1]: l += 1 return l + 1def decrement(nums, l, r): while l &lt; r and nums[r] == nums[r-1]: r -= 1 return r - 1 NOTEk-sum problem can be implemented by using recursion. We will add such implementation later.","link":"/wanderland/2019/02/20/4sum/"},{"title":"Two Sum II - Input array is sorted","text":"ProblemGiven an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Note: Your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. Example: 12345Input: numbers = [2,7,11,15], target = 9Output: [1,2]Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2. SolutionsThe key point is to take advantage of sorted array. We can use two pointers strategy or binary search method to solve this problem. Two solutions are shown below respectively. Solution with two pointers is relatively easy to catch, and it should be the first answer you provide in an interview. Two pointer solution: 123456789101112# Solution with two pointersdef twoSum(nums: 'List[int]', target: 'int') -&gt; 'List[int]': lo, hi = 0, len(nums) - 1 while lo &lt; hi: s = nums[lo] + nums[hi] if s == target: return [lo+1, hi+1] elif s &lt; target: lo += 1 else: hi -= 1 Binary search solution: Binary search solution is kind of difficult to understant compared with two pointer one. Basically it uses binary search algorithm to move start or end pointer faster rather than one step in each iteration. It tries to move start to a new position where nums[start] is the first value that nums[start] &gt;= target - nums[end] if the sum is less than target. Similar logic applies to end pointer. In each helper function, we only consider the pointer we care about. 123456789101112131415161718192021222324252627282930313233343536373839404142434445# Solution using binary searchdef twoSum(nums: 'List[int]', target: 'int') -&gt; 'List[int]': start, end = 0, len(nums) - 1 while start &lt; end: s = nums[start] + nums[end] if s == target: return [start+1, end+1] elif s &lt; target: # need to adjust start pointer start = binary_search_start(nums, start, end, target-nums[end]) else: # need to adjust end pointer end = binary_search_end(nums, start, end, target-nums[start])def binary_search_start(nums, start, end, key): ''' Move the start pointer to the position where nums[start] is the first element greater than or equal to the key ''' while start &lt;= end: mid = start + (end - start) // 2 if nums[mid] &lt; key: start = mid + 1 else: end = mid - 1 return startdef binary_search_end(nums, start, end, key): ''' Move the end pointer to the position where nums[end] is the last element less than or equal to the key ''' while start &lt;= end: mid = start + (end - start) // 2 if nums[mid] &gt; key: end = mid - 1 else: start = mid + 1 return end","link":"/wanderland/2019/02/10/2sum-sorted/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/wanderland/2018/12/29/hello-world/"},{"title":"Palindrome Number","text":"ProblemDetermine whether an integer is a palindrome. An integer is palindrome when it reads the same backward as forward. Example: 12Input: 121Output: true Example: 123Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. SolutionThe first solution coming intuitively is to convert the input to string, and then easily compare the str(input) with reverse(str(input)). NOTE As for Python, we don’t have the risk of being overflowed for int type, since the memory is allocated dynamically. The int object could be infinitely large theoretically. 12def is_palindrome(x: int) -&gt; bool: return str(x) == str(x)[::-1] The second way to address this problem is just following pure math. 12345678910def is_palindrome(x: int) -&gt; bool: if x &lt; 0: return False rev, tmp = 0, x while tmp: rev = rev * 10 + tmp % 10 tmp = tmp // 10 return rev == x","link":"/wanderland/2019/03/08/palindrome-number/"},{"title":"Power of Two","text":"ProblemGiven an integer, write a function to determine if it is a power of two. Example: 123Input: 1Output: trueExplanation: 2^0 = 1 Example: 123Input: 16Output: trueExplanation: 2^4 = 16 SolutionWe of course can follow the intuitive way to judge if the input is a power of two. But LeetCode gave me a 「Time Limit Exceeded」… Anyway, this method also suits Power of Three and Power of Four. 12345678def is_power_of_two(n: int) -&gt; bool: if n &lt;= 0: return False while not n % 2: n = n // 2 return n == 1 Another try goes to recursion. 12def is_power_of_two(n: int) -&gt; bool: return n &gt; 0 and ( n == 1 or ( n % 2 == 0 and isPowerOfTwo(n//2) ) ) Bit manipulation solution is a little bit tricky at first glance. it works based on the fact that n &amp; (n-1) == 0 if n is a power of two. Example: 123a = 16 which is 0b10000b = 15 which is 0b01111a &amp; b = 0 12345def is_power_of_two(n: int) -&gt; bool: if n &lt;= 0: return False return not (n &amp; (n-1) )","link":"/wanderland/2019/03/08/power-of-two/"},{"title":"Sorting Algorithms","text":"This post is aim to summerize a handful of fundamental sorting algoritms that one should be very familiar with. Bubble SortIt compares adjacent two elements in the input array to check if a swap is needed. The right half section is sorted.Time complexity is O(n^2).It is stable. 1234567891011121314def bubble_sort(seq): n = len(seq) if n &lt; 2 return for i in range(n): flag = False for j in range(n - i - 1): if seq[j] &gt; seq[j+1]: seq[j], seq[j+1] = seq[j+1], seq[j] flag = True if flag is False: break Insertion SortIt divides the input sequence into two parts: sorted and unsorted sections. Unsorted section starts from i to the end.It compares the first element seq[i] in unsorted section with element seq[j] in sorted part in reverse order step by step by moving sorted elements until a proper location is found.Time complexity is O(n^2).It is stable. 12345678910111213def insertion_sort(seq): n = len(seq) if n &lt; 2 return for i in range(1, n): value = seq[i] j = i - 1 while j &gt;= 0 and seq[j] &gt; value: seq[j+1] = seq[j] j -= 1 seq[j+1] = value Selection SortSimilarly, it divides the input into sorted and unsorted parts. It picks minimum value seq[min_idx] at each iteration to swap with head element seq[i] in the unsorted section.Time complexity is O(n^2).It is NOT stable. 12345678910111213def selection_sort(seq): n = len(seq) if n &lt; 2: return for i in range(n): min_idx = i for j in range(i+1, n): if seq[j] &lt; seq[min_idx]: min_idx = j if min_idx != i: seq[i], seq[min_idx] = seq[min_idx], seq[i] Merge SortIt at the beginning divides the input array recursively, and later rebuild it by merging two parts in ascending order. The merge implementation is the hinge.Time complexity is O(nlogn).It is stable. Recursion equation:1234merge_sort(l...r) = merge(merge_sort(l...m), merge(m+1...r))it terminates when:l &gt;= r 123456789101112131415161718192021222324252627282930def merge_sort(seq): sort(seq, 0, len(seq)-1)def sort(seq, l, r): if l &gt;= r: return m = l + (r - l) // 2 sort(seq, l, m) sort(seq, m+1, r) merge(seq, l, m, r)def merge(seq, l, m, r): i, j = l, m+1 tmp = [] while i &lt;= m and j &lt;= r: if seq[i] &lt;= seq[j]: tmp.append(seq[i]) i += 1 else: tmp.append(seq[j]) j += 1 start = i if i &lt;= m else j end = m if i &lt;= m else r tmp.extend(seq[start:end]) seq[:] = tmp Quick SortThe key is all about partition implementation. It picks the last element as pivot to make sure all elements before the pivot are less than it, and elements after it are greater.Time complexity is O(nlogn).It is NOT stable. Recursion equation:1234quick_sort(l...r) = quick_sort(l...p-1) + quick_sort(p+1...r)it terminates when:l &gt;= r 123456789101112131415161718192021222324def quick_sort(seq): sort(seq, 0, len(seq) - 1)def sort(seq, l, r): if l &gt;= r: return pivot = partition(seq, l, r) sort(seq, l, pivot-1) sort(seq, pivot+1, r)def partition(seq, l, r): pivot = seq[r] i = l for j in range(l, r): if seq[j] &lt; pivot: seq[i], seq[j] = seq[j], seq[i] i += 1 seq[i], seq[r] = seq[r], seq[i] return i Heap SortHeap Sort continuously swaps the top element (the maximum) with the last element in the heap, and build the heap again.Time complexity is O(nlogn).It is NOT stable. 12345678910111213141516171819202122232425262728293031323334353637def heap_sort(seq): build_heap(seq) heap_size = len(seq) - 1 for last in range(heap_size, 0, -1): seq[0], seq[last] = seq[last], seq[0] heap_size -= 1 heapify(seq, 0, heap_size) return seqdef build_heap(seq): ''' Only necessary to build heap from 0 to n // 2 because leaf nodes start from n // 2 + 1 ''' n = len(seq) - 1 for i in range(n // 2, -1, -1): heapify(seq, i, n)def heapify(seq, i, n): while True: l, r = 2 * i + 1, 2 * i + 2 max_idx = i if l &lt;= n and seq[i] &lt; seq[l]: max_idx = l if r &lt;= n and seq[max_idx] &lt; seq[r]: max_idx = r if max_idx == i: break seq[i], seq[max_idx] = seq[max_idx], seq[i] i = max_idx SummaryMerge Sort and Quick Sort are based on Divide and Conquer strategy. They are capable of sorting large-scale data, while others left are supposed to sort data in musch smaller size. Even though having the same time complexity, Heap Sort is not superior to Quick Sort. Heap Sort needs more swap processes, and heapify procedure does not access data in the array sequentially, unfriendly to CPU cache.","link":"/wanderland/2019/02/14/sorting/"},{"title":"Github 上值得关注的资源","text":"Python Programming alive-progressAn animated and smart Progress Bar for python wtfpythonExploring Python through counter-intuitive snippets PySnooperNever use print for debugging again clickPython composable command line interface toolkit httpxA next generation HTTP client for Python starletteThe little ASGI framework that shines noxFlexible test automation for Python Go Programming go-pryGo 语言互动式的 REPL 环境，可以直接运行 Go 脚本 Vim vim-orgmodeText outlining and task management for Vim based on Emacs’ Org-Mode nerd-fontsIconic font aggregator, collection, &amp; patcher Git git-flight-rules给使用 Git 的程序员处理各种情况的指南 Docker docker-library/docDocker 官方镜像的文档，可以借鉴官方标准的 Dockerfile 教学 diy-async-web-frameworkLearn how modern async web frameworks work, by writing simple clone from scratch pysheeetCollect python code snippets python-cheatsheetComprehensive Python Cheatsheet GitHub 上某人总结的各种技巧和经验涉及 Emacs，Linux，各种编程语言 其它 reverse-interview收集在面试中反问面试官的问题 Raft Visualization使用动画解释 Raft 一致性算法","link":"/wanderland/2019/08/26/articles/github/"},{"title":"一些有用的工具以及资源","text":"Linux bootlin搜索和查看 Linux 内核源代码的网站 Go Programming go-pryGo 语言互动式的 REPL 环境，可以直接运行 Go 脚本 Docker dive查看 Docker 镜像文件中的 layer 的工具 docker-slim JavaScript jsinspectJavaScript 检查重复代码的工具 前端 tesseract.js一个可以完成 N 多语言光学识别的 js 库 testcafe前端 UI 测试框架 DocusaurusFacebook 出品的 Markdown 静态文档网站的建站工具，Docusaurus 2 正在开发中 react-beautiful-dndReact 拖拽组件 majesticJest 测试框架的图形界面 uPlogA small, fast chart for time series, lines, areas, ohlc &amp; bars 组件库 ui-libraries收集了前端各种 UI 组件库 Semiotic一款 React 的数据可视化框架，很漂亮简洁 图标 ikonate开源的一套 SVG 图标 zwicon 图片 Upsplash免费的高清图片网站 Cool Backgrounds自动生成背景图片的网站 Sketchviz生成手绘风格的 Graphviz 图片 excalidraw简单易用的白板绘图 CSS CSS Gradient提供定制化的 CSS Gradient 样式 css-doodle一款 Web 组件使用 CSS 来制作绚烂的 pattern aigradientAI Generated Gradient Mac App Winds一款开源的 RSS 阅读和 Podcast APP VSCode Plugin Python Preview一款可以在编辑器中可视化 Python 执行过程的插件 TabNine基于深度学习的代码补全工具 Chrome 插件 Markdown Here使用 Markdown 写电子邮件，然后转换为 HTML OctoLinker可以将 Github 的代码中的模块加载语句变成链接直接跳转 Note Taking Memo可将内容同步到 Github’s gists 的软件 JSON JSON Generator一款自动生成虚拟 JSON 数据的工具 Dadroit JSON Viewer一款浏览大型 JSON 数据文件的桌面软件 fxCommand-line tool and terminal JSON viewer 其他 resume.io提供模版制作简历的网站 fusuma可以将 Markdown 文件转换成幻灯片，功能很强大 mkcert生成本地 HTTPS 加密证书的工具 refined-github为 Github 增加很多功能的浏览器扩展 nodeppt将 Markdown 文档转换成幻灯片，在浏览器中演示 termtosvg将命令行操作录制为 svg 动画 cartoonify使用摄像头，树莓派和热敏打印机拍出卡通图片 Toolfx.com网站收集了专供程序员使用的一些在线工具 Pock一款可以将 Mac 的 Dock 栏搬到 Touchbar Developer Jobs in Japan该网站收集了日本的软件工程师的职位机会 Rico’s cheatsheetsCheatsheet 大全 Nand Game网页游戏，通过组合虚拟电路，组装出一台计算机 diffconflictsGit 的两方合并算法 stackshare.io收集各个公司使用的技术栈，可以用来查看自己喜欢的公司使用的技术栈 Hexo theme cold stoneHexo 主题 LaTex SearchLaTex 搜索引擎。你给出英文描述，它返回符号的写法 percollate命令行抓取网页，生成 PDF slate创建美观的静态 API 文档的框架 SourceTrail可视化源码浏览器 Happy Hue提供配色设计方案的网站，可自定义配色 Insomnia开源 API 设计和调试的桌面软件 asciiflow在线画 ASCII 码框图的网站","link":"/wanderland/2019/06/02/articles/tools/"},{"title":"关于面试的一些资源","text":"System Designsystem-design-primer The AlgorithmsOpen Source resource for learning Data Structures &amp; Algorithms in various languanges","link":"/wanderland/2020/01/01/articles/interview/"},{"title":"学习资源","text":"算法 Data Structure Visualizations LeetCode 前300题目每道题都提供了多种解法和详细的分析 设计模式 Design Pattens for Humans Python Pattens Refactor Guru设计模式以及重构的资源，有售卖电子书 系统设计 Grokking the System Design Interview Python Python Tips通俗易懂的 Python 教程 Python Resources一位在美国上学的巴基斯坦小哥的 Blog 中收集的资源，这位小哥自己撰写了 Python Tips Python Parallel Programming CookbookPython Parallel Programming Cookbook 的中文翻译，仓库中也包含英文原版 SICP Python中文翻译在这里 Go Programming High Performance Go Workshop High Performance Go Workshop 翻译 Go 101 Advanced Go Programming BookGo 语言高级编程开源图书 Golangbot 系列教程翻译Golangbog 是国外开发者写的 Go 语言的初级教程 Linux linux-insides关于 linux 内核的开源书 pure bash bible 前端 RMind作者基于 React Hooks 和 flex 布局实现了思维导图，可以作为学习资源 Acceptance Test Driven Development with React一位中国的开发者撰写的关于前端测试方面的书 Node Best Practices 深入浅出现代 Web 编程一个芬兰的全栈公开课中文版 语言 Crafting Interpreters如何写一个解释器，其实就是如何自己设计并实现一门语言 网络 The Illustrated TLS Connection图解 HTTPS 协议对话过程 Computer Networking: Principles, Protocols and Practice英文开源电子书，介绍了计算机网络原理和各协议栈 HTTP/2 explained HTTP/3 explained 操作系统 x86 Assembly Guide 其它 Emulator 101从零开始讲解如何写一个 8080 处理器的模拟器 Processor Design使用通俗语言讲解 CPU 原理 反向面试收集了面试中反问面试官的问题 The Best CS Books作者认为的计算机科学中不错的书籍，其中涵盖编程，算法，编译，操作系统，网络等领域 Google developer documentation style guideGoogle 开发者文档风格指南 Git from the inside outGit 原理详解","link":"/wanderland/2019/04/14/articles/learn-resource/"},{"title":"教程","text":"Algorithms Data Structures Reference Data Structures and Algorithms An Integer Formula for Fibonacci Numbers Docker Dockerizing a React AppReact 应用的 Docker 化。文中介绍了如何将 React 应用打包成生产环境可用的容器 Intro Guide to Dockerfile Best Practices介绍编写 Dockerfile 的最佳实践, 节省构建时间、image 大小，增加可维护性、安全性和可重复性 Python 如何用 Python 实现一个简单的 JSON 解析器此文描述了使用 Python 如何实现一个简单的 JSON Parser，主要体现在词法分析 (lexical) 和语法分析 (syntactic) 两个步骤 Python PattensPython 语言中的设计模式 Golang Learning Golang from zero to hero Go 101 前端 How to Use SVG Patterns as Backgrounds教你如何手写一个 SVG 文件作为网页的背景图案 CSS 如何编写深色主题的 CSS本文介绍了 Yandex Mail 团队如何使用 CSS 代码实现 APP 上的深色主题 如何写网页的社交媒体分享功能 Unicode 字符与 CSS 背景本文介绍了使用 Unicode 字符来做 CSS 背景。续篇 如何设置粘性页尾本文介绍了如何使用 Flexbox 布局实现粘性页尾 Design 非设计师需要知道的设计原则本文介绍了四个简单基本的设计原则给非设计人员 测试 testcafe 教程本文介绍了前端 UI 测试框架 testcafe 架构 网站架构101介绍大型网站架构的基本知识 Serverless Best PracticesServerless 架构应该注意的问题 Scaling webapps for newbs &amp; non-techies本文介绍如何拓展网站服务，承受更大的访问量 其他 How does a CPU work Certificates for localhost本文介绍了如何为 localhost 生成证书 SQL Style GuideSQL 的风格指南 Learn LaTeX in 30 minsLaTeX 的快速入门教程 Baby’s First Garbage Collector本文介绍如何写一个简单的基于标记清除的垃圾回收器 YAML 表示多行字符串的9种方法 Asynchronous programming一系列的文章介绍异步编程 A Gentle Introduction to Multithreading一系列的介绍进程，线程，和并发的文章，浅显易懂 介绍 mv 命令无需两次键入文件名的技巧","link":"/wanderland/2019/06/16/articles/tutorials/"},{"title":"一些有趣的文章","text":"原理 只有 13 台 DNS 根域名服务器的原因此文解释了为什么 DNS 根域名服务器只有 13 个 IP 的原因 如何用 Python 实现一个简单的 JSON 解析器此文描述了使用 Python 如何实现一个简单的 JSON Parser，主要体现在词法分析 (lexical) 和语法分析 (syntactic) 两个步骤 Python Pragmatic UnicodeUnicode in Python2 and Python3 Unicode &amp; Character Encodings in Python: A Painless Guide解释了什么是 Character Encoding 以及 Unicode。全面介绍了 Python3 中 Unicode encoding 和 decoding Python PattensPython 语言中的设计模式 Things you’re probably not using in Python 3 - but should介绍了 Python 3 中的一些 features So you want to contribute to CPython: gather here!作者介绍了自己如何开始为 CPython 贡献代码的经历 Faster Docker builds with pipenv, poetry, or pip-tools How to Easily Use a Progress Bar in Python作者列举了一些比较受欢迎的进度条 Library A Visual Intro to NumPy and Data RepresentationNumpy 的可视化介绍 The state of type hints in PythonPython 类型系统的现状，比较详细 TimSortPython 的默认排序算法 TimSort 的基本原理 Avoiding Webscraping Throttling Using Python and Tor as a Proxy使用 Python 和 Tor 来做爬虫，避免被反爬 7 Habits to Improve the Performance of Python Programs提供了一些提升 Python 性能的建议 Linux Linux: a Portable Operating System大神 Linus Torvalds 当年的硕士毕业论文，介绍 Linux 系统如何适配不同的硬件架构 Unix as IDE展示如何用 Unix 命令行工具完成 IDE 的功能。中文翻译 How to write idempotent Bash scripts如何来编写幂等 Bash 脚本 Doubling checking if an email address exists作者展示如何使用 Linux 命令来确认邮件地址是否存在 前端 如何编写深色主题的 CSS本文介绍了 Yandex Mail 团队如何使用 CSS 代码实现 APP 上的深色主题 How to Implement an HTTP Request Library with Axios本文分析 axios 的内部设计 Optimizing React: Virtual DOM explainedReact 的虚拟 DOM 机制的详细解释，JSX 的代码如何编程虚拟 DOM 的数据结构 设计 非设计师需要知道的设计原则本文介绍了四个简单基本的设计原则给非设计人员 测试 testcafe 教程本文介绍了前端 UI 测试框架 testcafe Web HTTP Security HeadersHTTP 头信息中与安全相关的字段 从图片优化说起如何使用 Node.js 进行各种图片操作，优化 Web 图片体验 Network The Story of the PING Program本文是我们常用的 PING 的命令的作者撰写的是如何写出这个工具的 How does DHCP work本文介绍 DHCP 协议的运作过程 Everything You Need to Know about Networking on AWS本文介绍了 AWS 的 VPC 网络，浅显易懂 What every developer should know about TCP本文简单介绍了 TCP 的拥塞控制原理以及如果利用带宽 Kubernetes A Tutorial Introduction to KubernetesKubernetes 上手入门教程 其他 Why We’re Switching to gRPC本文介绍了为什么作者的团队选择了 gRPC 作为服务间的通信方式 20 lines of code that will beat A/B testing every time本文作者提出了一种超越 A/B 测试的算法，并且很容易来实现 Router Hacking How to bypass “slider CAPTCHA” with JS and Puppeteer本文展示如何使用 Puppeteer 的自动化脚本破解滑块验证 约定式提交本文展示代码仓库提交的信息规范标准 Why you can have millions of Goroutines but only thousands of Java Threads作者介绍了同一台机器上为什么 Java 的线程只能有几千个但是 Goroutine 却可以有数百万个 Writing Docs at Amazon作者介绍了在亚马逊如何写文档，里面有很多中肯的决定","link":"/wanderland/2019/06/02/articles/articles/"},{"title":"Binary Tree Inorder Travesal","text":"ProblemGiven a binary tree, return the inorder traveral of its nodes’ values. Example: 12345678Input: [1,null,2,3] 1 \\ 2 / 3Output: [1,3,2] SolutionThis is a MUST-KNOW algorithm problem. Usually we can recursively and iteratively solve this problem. Here I will present the iterative way: We start from the root and go all the way, as deep as we can, into its left child tree Along the way, we push all the visited nodes into a Stack Whenever we meet None, we pop from the stack and mark the popped node We start to explore the right child tree of the popped node We repeat the steps above until the stack is empty 1234567891011121314151617181920212223class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Nonedef inorder_traversal(root: TreeNode) -&gt; List[int]: res = [] if not root: return res stack, curr = [], root while stack or curr: while curr: stack.append(curr) curr = curr.left curr = stack.pop() res.append(curr.val) curr = curr.right return res","link":"/wanderland/2019/12/11/leetcode/tree/binary-tree-inorder-traversal/"},{"title":"Binary Tree Preorder Traversal","text":"ProblemGiven a binary tree, return the preorder traversal of its nodes’ values. Example: 12345678Input: [1,null,2,3] 1 \\ 2 / 3Output: [1,2,3] SolutionThis is a MUST-KNOW algorithm problem too. We solve it using Stack way again. Recursive way is too straightforward… We start from the top node in the Stack and visit it at first hand We put the top node’s RIGHT children into the Stack We then put the top node’s LEFT children into the Stack We stop the traversal until the Stack is empty 12345678910111213141516171819202122class TreeNode: self.val = x self.left = None self.right = Nonedef preorder_traversal(root: TreeNode) -&gt; List[int]: res = [] if not root: return res stack = [root] while stack: curr = stack.pop() res.append(curr.val) if curr.right: stack.append(curr.right) if curr.left: stack.append(curr.left) return res","link":"/wanderland/2019/12/14/leetcode/tree/binary-tree-preorder-traversal/"},{"title":"Convert Sorted List to Binary Search Tree","text":"ProblemGiven a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: 123456789Given the sorted linked list: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \\ -3 9 / / -10 5 SolutionIt is relatively easy to solve this problem recursively (Depth-first). The idea is to find the middle node in the linked list as the root of the binary search tree, and do the same process for both left and right parts of the linked list. Please note that we need to disconnect the left and right portions of the list after we find the middle node. 12345678910111213141516171819202122232425262728293031323334353637383940class ListNode: def __init__(self, x): self.val = x self.next = Noneclass TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Nonedef sorted_list_to_bst(head: ListNode) -&gt; TreeNode: if head is None: return middle = find_middle_node(head) root = TreeNode(middle.val) root.left = sorted_list_to_bst(head) root.right = sorted_list_to_bst(middle.next) return rootdef find_middle_node(head: ListNode) -&gt; ListNode: prev = None slow = fast = head while fast and fast.next: prev = slow slow = slow.next fast = fast.next.next # disconnect left and right parts if prev: prev.next = None return slow","link":"/wanderland/2019/09/14/leetcode/linked_list/convert-sorted-list-to-binary-search-tree/"},{"title":"Copy List with Random Pointer","text":"ProblemA linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. Note:You must return the copy of the given head as a reference to the cloned list. SolutionThis problem truely did give me headache. The difficulty comes from the additional random pointer. It is very straightforward if only the next pointer exists. We can just simply clone the original linked list by iterating it. But this time we have another random pointer. The key to solve this problem is to build up the mapping between the original list and cloned list, and hash table would be the perfect data structure. 1mapping: {original_node: cloned_node} Obviously we need to iterate the linked list twice. We have to build up the mapping in the first pass, and weave the cloned list in the second pass. 12345678910111213141516171819202122232425class Node: def __init__(self, val, next, random): self.val = val self.next = next self.random = randomdef copy_random_list(head: Node) -&gt; Node: if head is None: return mapping = {} curr = head while curr: mapping[curr] = Node(curr.val, None, None) curr = curr.next curr = head while curr: mapping[curr].next = mapping.get(curr.next) # curr_cloned.next = (curr.next)_cloned mapping[curr].random = mapping.get(curr.random) # curr_cloned.random = (curr.random)_cloned curr = curr.next return mapping[head] # head_cloned Follow-upThis solution uses additional space to maintain the mapping relationship. There is another solution which claims that it only uses O(1) space. The bottom line is still keeping the mapping, but it uses another form to do that: it interleaves the original and cloned lists. 123 1 -&gt; 1&apos; -&gt; 2 -&gt; 2&apos; -&gt; null |curr So we can use the following formula to make the random pointers of the cloned nodes correct. 1curr.next.random = curr.random.next But at the end, we need to pick up the cloned nodes and reconnect their next pointers.","link":"/wanderland/2019/10/24/leetcode/linked_list/copy-list-with-random-pointer/"},{"title":"Delete Node in a Linked List","text":"ProblemWrite a function to delete a node (except the tail) in a singly linked list, given only access to that node. Example 1: 123Input: head = [4,5,1,9], node = 5Output: [4,1,9]Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function. Example 2: 123Input: head = [4,5,1,9], node = 1Output: [4,5,9]Explanation: You are given the third node with value 1, the linked list should become 4 -&gt; 5 -&gt; 9 after calling your function. Note: The linked list will have at least two elements. All of the nodes’ values will be unique. The given node will not be the tail and it will always be a valid node of the linked list. Do not return anything from your function. SolutionThis problem is very similar to traditional node deletion in linked list except the fact that we are given the target node instead of the head. Although simple enough, it provides up another way to delete a node in linked list. 123456789class ListNode: def __init__(self, x): self.val = x self.next = Nonedef delete_node(node: ListNode): node.val = node.next.val node.next = node.next.next","link":"/wanderland/2019/11/23/leetcode/linked_list/delete-node-in-a-linked-list/"},{"title":"Add Two Numbers","text":"ProblemYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. Example: 123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807 SolutionsAt the first glance, we need to solve this problem with regular way in math, adding digits at the same position one by one. However, the edge case is that the resulting list may have an extra carry bit. Sentinel strategy is also applied in here. 123456789101112131415161718192021222324class ListNode: def ___init___(self, x): self.val = x self.next = Nonedef add_two_numbers(l1: ListNode, l2: ListNode) -&gt; ListNode: dummy = curr = ListNode(0) carry = 0 while l1 or l2 or carry: if l1: carry += l1.val l1 = l1.next if l2: carry += l2.val l2 = l2.next curr.next = ListNode(carry % 10) curr = curr.next carry //= 10 return dummy.next","link":"/wanderland/2019/05/23/leetcode/linked_list/add-two-numbers/"},{"title":"Insertion Sort List","text":"ProblemSort a linked list using insertion sort. Algorithm of Insertion Sort: Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain. Example 1: 12Input: 4-&gt;2-&gt;1-&gt;3Output: 1-&gt;2-&gt;3-&gt;4 Example 2: 12Input: -1-&gt;5-&gt;3-&gt;4-&gt;0Output: -1-&gt;0-&gt;3-&gt;4-&gt;5 SolutionThe ordinary insertion sort looks like the following pseudocode: 1234567891011i ← 1while i &lt; length(A) x ← A[i] j ← i - 1 while j &gt;= 0 and A[j] &gt; x A[j+1] ← A[j] j ← j - 1 end while A[j+1] ← x i ← i + 1end while However the data structure we are dealing with is linked list. The implementation will be a little different. Because this is a singly linked list, we are only able to loop from the start instead of looping reversely in the sorted section. Note We don’t link the dummy node with head. The code prev.next = curr inside the while loop will do it for us. We don’t have to start from the first node to search an appropriate location in each iteration. If the current node’s value is greater than the last node (prev) in the sorted section, then there is no need to do prev = dummy. 12345678910111213141516171819202122232425262728class ListNode: def __init__(self, x): self.val = x self.next = Nonedef insertion_sort_list(head: ListNode) -&gt; ListNode: if not head: return prev = dummy = ListNode(0) curr = head while curr: # Only search from the first node when current val is less than # the largest node value in sorted section if prev.next and cur.val &lt; prev.next.val: prev = dummy while prev.next and prev.next.val &lt; cur.val: prev = prev.next tmp = curr.next curr.next = prev.next prev.next = curr curr = tmp return dummy.next","link":"/wanderland/2019/11/02/leetcode/linked_list/insertion-sort-list/"},{"title":"Design Linked List","text":"ProblemDesign your implementation of the linked list. You can choose to use the singly linked list or the doubly linked list. A node in a singly linked list should have two attributes: val and next. val is the value of the current node, and next is a pointer/reference to the next node. If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed. Implement these functions in you linked list class: get(index) : Get the value of the index-th node in the linked list. If the index is invalid, return -1. addAtHead(val) : Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. addAtTail(val) : Append a node of value val to the last element of the linked list. addAtIndex(index, val) : Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. deleteAtIndex(index) : Delete the index-th node in the linked list, if the index is valid. SolutionDesign customized data structure problem. For linked list, we normally need to maintain a head node and the size of the linked list as instance attributes. Just pay attention to some edge cases like delete head node, or add node at tail when list is empty, etc. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class MyLinkedList: def __init__(self): self.head = None self.size = 0 def get(self, index: int) -&gt; int: if index &lt; 0 or index &gt;= self.size: return -1 if self.head is None: return -1 curr = self.head for _ in range(index): curr = curr.next return curr.val def add_at_head(self, val: int) -&gt; int: node = ListNode(val) node.next = self.head self.head = node self.size += 1 def add_at_tail(self, val: int) -&gt; None: curr = self.head if curr is None: self.head = ListNode(val) else: for _ in range(self.size - 1): curr = curr.next curr.next = ListNode(val) self.size += 1 def add_at_index(self, index: int, val: int) -&gt; None: if index &lt; 0 or index &gt; self.size: return if index == 0: self.add_at_head(val) elif index == self.size: self.add_at_tail(val) else: curr = self.head for _ in range(index - 1): curr = curr.next node = ListNode(val) node.next = curr.next curr.next = node self.size += 1 def delete_at_index(self, index: int) -&gt; None: if self.head is None: return if index &lt; 0 or index &gt;= self.size: return curr = self.head if index == 0: self.head = curr.next else: for _ in range(index - 1): curr = curr.next curr.next = curr.next.next self.size -= 1","link":"/wanderland/2019/12/08/leetcode/linked_list/design-linked-list/"},{"title":"Add Two Numbers II","text":"ProblemYou are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Follow up:What if you cannot modify the input lists? In other words, reversing the lists is not allowed. Example: 12Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 8 -&gt; 0 -&gt; 7 SolutionThis is kind of the variant of Add Two Numbers. This time we are given with lists representing decimal numbers in ordinary order, and this causes minor trouble because it seems like we have to add up numbers from the tails. So how could we add the numbers without reversing the lists? We probably need to exchange time with space this time. Certainly the data structure Stack comes to help. We can add the two lists by pushing them into two stacks respectively, and then popping the numbers from the tops. Also we can build up the final result list beginning from the end. 12345678910111213141516171819202122232425262728293031class ListNode: def __init__(self, x): self.val = x self.next = Nonedef add_two_numbers(l1: ListNode, l2: ListNode) -&gt; ListNode: stack_one, stack_two = [], [] while l1: stack_one.append(l1.val) l1 = l1.next while l2: stack_two.append(l2.val) l2 = l2.next s = 0 head = post = None while stack_one or stack_two or s: item_one = stack_one.pop() if stack_one else 0 item_two = stack_two.pop() if stack_two else 0 s += item_one + item_two head = ListNode(s % 10) head.next = post post = head s //= 10 return head","link":"/wanderland/2019/11/23/leetcode/linked_list/add-two-numbers-ii/"},{"title":"Flatten a Multilevel Doubly Linked List","text":"ProblemYou are given a doubly linked list which in addition to the next and previous pointers, it could have a child pointer, which may or may not point to a separate doubly linked list. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure, as shown in the example below. Flatten the list so that all the nodes appear in a single-level, doubly linked list. You are given the head of the first level of the list. Example:123456789Input: 1---2---3---4---5---6--NULL | 7---8---9---10--NULL | 11--12--NULLOutput:1-2-3-7-8-11-12-9-10-4-5-6-NULL SolutionWe can think about this problem like DFS traveral of Tree. Whenever we reach a node with child branch, we follow the path of child branch. Stack is the regular data structure in DFS. 12345678910111213141516171819202122232425262728class Node: def __init__(self, val, prev, next, child): self.val = val self.prev = prev self.next = next self.child = childdef flatten(head: Node) -&gt; Node: if not head: return stack, prev = [head], None while stack: curr = stack.pop() if prev: prev.next, curr.prev = curr, prev if curr.next: stack.append(curr.next) if curr.child: stack.append(curr.child) curr.child = None prev = curr return head And without using Stack, we can follow our intuition to solve it too. When we reach a node with child branch, we follow the path of child branch and iterate to the end without caring if there is more depth along the path. We “merge” the child path to the upper one. 1234567891011121314151617181920212223242526272829class Node: def __init__(self, val, prev, next, child): self.val = val self.prev = prev self.next = next self.child = childdef flatten(head: None) -&gt; None curr = head while curr: if curr.child: tmp = curr.next curr.next = curr.child curr.child.prev = curr curr.child = None child = curr.next while child.next: child = child.next child.next = tmp if tmp: tmp.prev = child curr = curr.next return head","link":"/wanderland/2019/12/07/leetcode/linked_list/flatten-multilevel-doubly-linked-list/"},{"title":"Binary Tree Postorder Traversal","text":"ProblemGiven a binary tree, return the postorder traveral of its nodes’ values. Example: 12345678Input: [1,null,2,3] 1 \\ 2 / 3Output: [3,2,1] SolutionMUST-KNOW problem. Postorder traversal of a binary tree is leveraging an additional flag to record if each node is visited or not. This is because we have to know the node at the top of the Stack is visited or not, so that we can know if we need to continue to explore or not. We start from the node at the top of the Stack If the node has been marked visited, then we put it into the result. This starts to happen when all nodes in the Stack are visited If the node is not visited, we store it back into the Stack with status visited and also store its offsprings to the Stack with status NOT visited We stop the traveral when the Stack is empty 1234567891011121314151617181920212223242526class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Nonedef postorder_traversal(root: TreeNode) -&gt; List[int]: res = [] if not root: return res stack = [(root, False)] while stack: curr, visited = stack.pop() if visited: res.append(curr.val) else: # It's post-ordered from top to bottom stack.append((curr, True)) if curr.right: stack.append((curr.right, False)) if curr.left: stack.append((curr.left, False)) return res","link":"/wanderland/2019/12/15/leetcode/tree/binary-tree-postorder-traversal/"},{"title":"Intersection of Two Linked Lists","text":"ProblemWrite a program to find the node at which the intersection of two singly linked lists begins. Notes: If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns. You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory. SolutionThe trick to solve this problem is to redirect the pointer to the head of the other list when reaching the end. If the two lists are not equal in length, two pointers will definitely meet at the intersection node after the redirects. I think the code will explain the solution better. 12345678910111213141516class ListNode: def __init__(self, x): self.val = x self.next = Nonedef get_intersection_node(head_a: ListNode, head_b: ListNode) -&gt; ListNode: if head_a is None or head_b is None: return curr_a, curr_b = head_a, head_b while curr_a != curr_b: curr_a = curr_a.next if curr_a else head_b curr_b = curr_b.next if curr_b else head_a return curr_a","link":"/wanderland/2019/11/17/leetcode/linked_list/intersection-of-two-linked-lists/"},{"title":"Linked List Components","text":"ProblemWe are given head, the head node of a linked list containing unique integer values. We are also given the list G, a subset of the values in the linked list. Return the number of connected components in G, where two values are connected if they appear consecutively in the linked list. Example 1:123456Input: head: 0-&gt;1-&gt;2-&gt;3G = [0, 1, 3]Output: 2Explanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components. Example 2:123456Input: head: 0-&gt;1-&gt;2-&gt;3-&gt;4G = [0, 3, 1, 4]Output: 2Explanation: 0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components. SolutionTo count how many connected components, we turn to count how many times we encounter the case: 1curr.val in G but curr.next.val not in G This number exactly shows how many connected components in the list based on the given subset values. Note the getattr in the solution, it perfectly deals with the case when moving to the last element. 1234567891011121314151617class ListNode: def __init__(self, x): self.val = x self.next = Nonedef num_components(head: ListNode, g: List[int]) -&gt; int: unique_g = set(g) res, curr = 0, head while curr: if curr.val in unique_g and \\ getattr(curr.next, 'val', None) not in unique_g: res += 1 curr = curr.next return res","link":"/wanderland/2019/12/07/leetcode/linked_list/linked-list-components/"},{"title":"Linked List Cycle II","text":"ProblemGiven a linked lsit, return the node where the cycle begins. If there is no cycle, return null. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. if pos is -1, then there is no cycle in the linked list. Note: Do not modify the linked list. Example 1: 123Input: head = [3,2,0,-4], pos = 1Output: tail connects to node index 1Explanation: There is a cycle in the linked list, where tail connects to the second node. Example 2: 123Input: head = [1,2], pos = 0Output: tail connects to node index 0Explanation: There is a cycle in the linked list, where tail connects to the first node. Example 3: 123Input: head = [1], pos = -1Output: no cycleExplanation: There is no cycle in the linked list. SolutionThis is the follow-up question of the Linked List Cycle. First we need to make some mathematical derivations. Assume the linked list does have a cycle, we say: 1234a: the distance between the head node and the node where cycle beginsl: the cycle lengthk: the distance between the node where two pointers meet and the node where cycle beginsx: the distance that the slow pointer travels When two pointers meet, the fast node must have traveled one more cycle length distance. So we can have: 1234x = a + (l - k)2x = a + l + (l - k)which gives: a = k This result gives that when we find the node where two pointers meet, we can find the node where the cycle begins by moving a pointer (which points to the head node) and another pointer (which points to the node where two pointers met) at the same time. The desired result will be the node where these two pinters meet. Here follows the code: 123456789101112131415161718192021222324252627282930class ListNode: def __init__(self, x): self.val = x self.next = Nonedef detect_cycle(head: ListNode) -&gt; ListNode: if not head: return meet_node = find_meet_node(head) if not meet_node: return while head != meet_node: head, meet_node = head.next, meet_node.next return headdef find_meet_node(node: ListNode) -&gt; ListNode: slow = fast = node while fast and fast.next: slow, fast = slow.next, fast.next.next if slow == fast: return slow return","link":"/wanderland/2019/10/17/leetcode/linked_list/linked-list-cycle-ii/"},{"title":"Merge k Sorted Lists","text":"ProblemMerge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Example: 1234567Input:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 SolutionsThis is a perfect case where heap data structure applies. We can construct a mininum heap at the beginning, and put new node into the heap after retrieving the minimum node each time. Note Pyhton 3 has different implementation in PriorityQueue module. Dealing with tasks with same priority, we have to put some element to keep the stability. I use timestamp in here. 1234567891011121314151617181920212223242526import timefrom queue import PriorityQueueclass ListNode: def ___init___(self, x): self.val = x self.next = Nonedef merge_k_lists(lists: List[ListNode]) -&gt; ListNode: q = PriorityQueue() for l in lists: if l: q.put((l.val, time.time(), l)) dummy = curr = ListNode(0) while not q.empty(): val, _, node = q.get() curr.next = node curr = curr.next node = node.next if node: q.put((node.val, time.time(), node)) return dummy.next","link":"/wanderland/2019/05/29/leetcode/linked_list/merge-k-lists/"},{"title":"Odd Even Linked List","text":"ProblemGiven a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(n) time complexity. Example 1: 12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL Example 2: 12Input: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULLOutput: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL Note: The relative order inside both the even and odd groups should remain as it was in the input. The first node is considered odd, the second node even and so on. SolutionTwo pointers again… It’s very straightforward. 123456789101112131415161718192021class ListNode: def __init__(self, x): self.val = x self.next = Nonedef odd_even_list(head: ListNode) -&gt; ListNode: if head is None: return odd, even, even_head = head, head.next, head.next while even and even.next: odd.next = odd.next.next odd = odd.next even.next = even.next.next even = even.next odd.next = even_head return head","link":"/wanderland/2019/11/23/leetcode/linked_list/odd-even-linked-list/"},{"title":"Next Greater Node in Linked List","text":"ProblemWe are given a linked list with head as the first node. Let’s number the nodes in the list: node_1, node_2, node_3, … etc. Each node may have a next larger value: for node_i, next_larger(node_i) is the node_j.val such that j &gt; i, node_j.val &gt; node_i.val, and j is the smallest possible choice. If such a j does not exist, the next larger value is 0. Return an array of integers answer, where answer[i] = next_larger(node_{i+1}). Note that in the example inputs (not outputs) below, arrays such as [2,1,5] represent the serialization of a linked list with a head node value of 2, second node value of 1, and third node value of 5. Example 1:12Input: [2,1,5]Output: [5,5,0] Example 2:12Input: [2,7,4,3,5]Output: [7,0,5,5,0] Example 3:12Input: [1,7,5,1,9,2,5,1]Output: [7,9,9,9,0,5,0,0] SolutionWhile moving forward along the linked list, we also push the node into a stack. When we find the current node’s value is greater than the stack top’s value, we find the next greater value. Every node in the stack should have next_greater(node in stack) = current_node. 1234567891011121314151617181920class ListNode: def __init__(self, x): self.val = x self.next = Nonedef next_large_nodes(head: ListNode) -&gt; List[int]: res, stack, curr = [], [], head while curr: while stack and stack[-1][1] &lt; curr.val: res[stack.pop()[0]] = curr.val stack.append((len(res), curr.val)) # extend res for next loop res.append(0) curr = curr.next return res","link":"/wanderland/2019/12/08/leetcode/linked_list/next-greater-node-in-linked-list/"},{"title":"Partition List","text":"ProblemGiven a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original order of the nodes in each of the two partitions. Example: 12Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 SolutionThe strategy to solve this problem is kind of straightforward: we can start with two pointers, one is going to knit all nodes less than x and another with the rest. We finish the problem by connecting the two lists together. The time complexity is O(n) and space complexity is O(1). 1234567891011121314151617181920212223class ListNode: def __init__(self, x): self.val = x self.next = Nonedef partition_list(head: ListNode, x: int) -&gt; ListNode: before_dummy = before = ListNode(0) after_dummy = after = ListNode(0) while head: if head.val &lt; x: before.next = head before = before.next else: after.next = head after = after.next head = head.next after.next = None # DON'T forget to cut off the tail's next before.next = after_dummy.next return before.dummy","link":"/wanderland/2019/09/11/leetcode/linked_list/partition-list/"},{"title":"Palindrome Linked List","text":"ProblemGiven a singly linked list, determine if it is a palindrome. Example 1: 12Input: 1-&gt;2Output: false Example 2: 12Input: 1-&gt;2-&gt;2-&gt;1Output: true Follow up:Could you do it in O(n) time and O(1) space? SolutionThe quick thought should be reverse half of the list. Obviously it is more efficient to reverse the first half while traversing the list to find the middle node. And be careful that we need to deal with the case of odd-length list. And it is noticeable that we can do one-line reverse with the help of sequence unpacking feature in Python. 12345678910111213141516171819202122232425262728class ListNode: def __init__(self, x): self.val = x self.next = Nonedef is_palindrome(head: ListNode) -&gt; bool: prev, slow, fast = None, head, head while fast and fast.next: fast = fast.next.next tmp = slow.next slow.next = prev prev = slow slow.next = tmp # One-line reverse # prev, prev.next, slow = slow, prev, slow.next # Odd-length case if fast is not None: slow = slow.next while prev and prev.val == slow.val: prev, slow = prev.next, slow.next return not prev","link":"/wanderland/2019/11/23/leetcode/linked_list/palindrome-linked-list/"},{"title":"Linked List Cycle","text":"ProblemGiven a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integer pos which represents the position (o-indexed) in the linked list where tail connects to. if pos is -1, then there is no cycle in the linked list. Example 1: 123Input: head = [3,2,0,-4], pos = 1Output: trueExplanation: There is a cycle in the linked list, where tail connects to the second node. Example 2: 123Input: head = [1,2], pos = 0Output: trueExplanation: There is a cycle in the linked list, where tail connects to the first node. Example 3: 123Input: head = [1], pos = -1Output: falseExplanation: There is no cycle in the linked list. SolutionThis problem was so popular in technical interview that most companies already removed it from the problem pools. The idea behind the solution is to apply two pointers technique. If a cycle does exist, the fast pointer will eventually catch up the slow pointer. 123456789101112131415class ListNode: def __init__(self, x): self.val = x self.next = Nonedef has_cycle(head: ListNode) -&gt; bool: slow = fast = head while fast and fast.next: slow, fast = slow.next, fast.next.next if slow == fast: return True return False","link":"/wanderland/2019/10/16/leetcode/linked_list/linked-list-cycle/"},{"title":"Remove Duplicates from Sorted List II","text":"ProblemGiven a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Example 1: 12Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5Output: 1-&gt;2-&gt;5 Example 2: 12Input: 1-&gt;1-&gt;1-&gt;2-&gt;3Output: 2-&gt;3 SolutionSimilar to the problem in leetcode 82, we compare current and next node. But this time we need a prev reference in order to connect the next node with distinct value. 12345678910111213141516171819202122232425class ListNode: def __init__(self, x): self.val = x self.next = Nonedef delete_duplicates(head: ListNode) -&gt; ListNode: if head is None or head.next is None: return head prev = dummy = ListNode(0) dummy.next = head while head and head.next: if head.val == head.next.val: while head and head.next and head.val == head.next.val: head = head.next prev.next = head.next else: prev = head head = head.next return dummy.next","link":"/wanderland/2019/09/10/leetcode/linked_list/remove-duplicates-from-sorted-list-ii/"},{"title":"Reorder List","text":"ProblemGiven a singly linked list L: L_0 -&gt; L_1 -&gt; ... -&gt; L_n-1 -&gt; L_nreorder it to: L_0 -&gt; L_n -&gt; L_1 -&gt; L_n-1 -&gt; L_2 -&gt; L_n-2 -&gt; ... You may not modify the values in the list’s nodes, only nodes itself may be changed. Example 1: 1Given 1-&gt;2-&gt;3-&gt;4, reorder it to 1-&gt;4-&gt;2-&gt;3. Example 2: 1Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3. SolutionsThe key to solve this problem is: Reverse the second half of the list Unlink the first half and the reversed second half of the list Interleave the two halves NotePay attention to the code section doing the interleaving. This is a general pattern. 12345678910111213141516171819202122232425262728class ListNode: def ___init___(self, x): self.val = x self.next = Nonedef reorder_list(head: ListNode) -&gt; None: if not head and not head.next: return prev, slow, fast = None, head, head while fast and fast.next: prev = slow slow = slow.next fast = fast.next.next right = reverse(slow) # Reverse the second half prev.next = None # Unlink # Interleave two halves left = head while left and right: temp = left.next left.next = right left = left.next right = temp","link":"/wanderland/2019/11/02/leetcode/linked_list/reorder-list/"},{"title":"Rotate List","text":"ProblemGiven a linked list, rotate the list to the right by k places, where k is non-negative. Example 1: 12345Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULLExplanation:rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULLrotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL Example 2: 1234567Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4Output: 2-&gt;0-&gt;1-&gt;NULLExplanation:rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULLrotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULLrotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULLrotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL SolutionsThe key to solve this problem is making a cyclic linked list by connecting the tail with the head, and then searching for the new head node after the rotate happens. The code is not complex and relatively self explanatory. 12345678910111213141516171819202122232425class ListNode: def ___init___(self, x): self.val = x self.next = Nonedef rotate_right(head: ListNode, k: int) -&gt; ListNode: if head is None: return curr, length = head, 1 while curr.next: curr = curr.next length += 1 curr.next = head # make a loop tail = head for _ in range(length - k % length - 1): tail = tail.next res = tail.next # the returned head node tail.next = None return res","link":"/wanderland/2019/09/08/leetcode/linked_list/rotate-list/"},{"title":"Remove Linked List Elements","text":"ProblemRemove all elements from a linked list of integers that have value val. Example: 12Input: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6Output: 1-&gt;2-&gt;3-&gt;4-&gt;5 SolutionI’m just speechless about how straightforward it is to solve this problem. I’m going to show iterative solution first. 1234567891011121314151617class ListNode: def __init__(self, x): self.val = x self.next = Nonedef remove_elements(head: ListNode, val: int) -&gt; ListNode: dummy = prev = ListNode(0) dummy.next = head while prev.next: if prev.next.val == val: prev.next = prev.next.next else: prev = prev.next return dummy.next And there is another way to solve it by recursion. 123456def remove_elements(head: ListNode, val: int) -&gt; ListNode: if head is None: return head.next = remove_elements(head.next, val) return head.next if head.val == val else head","link":"/wanderland/2019/11/18/leetcode/linked_list/remove-linked-list-elements/"},{"title":"Remove Duplicates from Sorted List","text":"ProblemGiven a sorted linked list, delete all duplicates such that each element appear only once. Example 1: 12Input: 1-&gt;1-&gt;2Output: 1-&gt;2 Example 2: 12Input: 1-&gt;1-&gt;2-&gt;3-&gt;3Output: 1-&gt;2-&gt;3 SolutionTo solve this problem, we compare current and next node. If two adjacent nodes’ values are same, the next node is skipped. The solution is relatively intuitive. 123456789101112131415161718class ListNode: def __init__(self, x): self.val = x self.next = Nonedef delete_duplicates(head: ListNode) -&gt; ListNode: if head is None: return curr = head while curr and curr.next: if curr.val == curr.next.val: curr.next = curr.next.next else: curr = curr.next return head","link":"/wanderland/2019/09/09/leetcode/linked_list/remove-duplicates-from-sorted-list/"},{"title":"Remove Nth Node From End of List","text":"ProblemGiven a linked list, remove the n-th node from the end of list and return its head. Example: 12Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. SolutionsThis problem is a perfect match for two pointer strategy. But in this case, we don’t declare slow and fast starting at the same position because we need to think about the edge case: when the removed node is head node. Note We use range to form a loop whenever possible because range is implemented in C language at the bottom. 1234567891011121314151617181920class ListNode: def ___init___(self, x): self.val = x self.next = Nonedef remove_nth_from_end(head: ListNode, n: int) -&gt; ListNode: slow = dummy = ListNode(0) dummy.next = fast = head for _ in range(n): fast = fast.next while fast: slow = slow.next fast = fast.next slow.next = slow.next.next return dummy.next","link":"/wanderland/2019/05/30/leetcode/linked_list/remove-nth-node-from-end/"},{"title":"Reverse Nodes in k-Group","text":"ProblemGiven a linked list, reverse the nodes of a linked list k at a time and return its modified list.k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. Example: 12345Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 Note: Only constant extra memory is allowed. You may not alter the values in the list’s nodes, only nodes itself may be changed. SolutionsWe can use the solution in Reverse Linked List to reverse each group of the list. And then connect the tail of previous reversed part with the head of the next reversed part. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from typing import Tupleclass ListNode: def ___init___(self, x): self.val = x self.next = Nonedef reverse_k_group(head, k): \"\"\" Inside each call stack: - try to iterate k times to check if there are enough k nodes to reverse - reverse k nodes starting from the head of current group - connect the head (which is the tail after reversed) of the current group with the head of the next reversed k-node group - return the head of current reversed group \"\"\" count, curr = 0, head while count &lt; k and curr: curr = curr.next count += 1 if count &lt; k: return head prev, nxt_head = reverse(head, k) head.next = reverse_k_group(nxt_head, k) return prevdef reverse(head: ListNode, k: int) -&gt; Tuple[ListNode, ListNode]: \"\"\" Reverse a single group of nodes For example: k = 3 Before: prev curr | | 1 -&gt; 2 -&gt; 3 -&gt; 4 After: prev curr | | 1 &lt;- 2 &lt;- 3 -&gt; 4 \"\"\" prev, curr = None, head for i in range(count): tmp = curr.next curr.next = prev prev = curr curr = tmp return prev, curr","link":"/wanderland/2019/06/02/leetcode/linked_list/reverse-nodes-k-group/"},{"title":"Reverse Linked List","text":"ProblemReverse a singly linked list. Example: 12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both? SolutionsThe iterative solution is relatively straightforward by flipping the current node’s next pointer. But recursive solution is slightly trickier. We need to think about it backwards. Assume from node n(k+1) to n(m) has been reversed and we are at node n(k). 1n(1) -&gt; ... -&gt; n(k-1) -&gt; n(k) -&gt; n(k+1) &lt;- ... &lt;- n(m) We want n(k+1)’s next node point to n(k). So we need to do 12n(k).next.next = n(k)n(k).next = NULL Don’t forget that we need to pop up the tail as the final result. 12345678910111213141516class ListNode: def ___init___(self, x): self.val = x self.next = Nonedef reverse_list(head: ListNode) -&gt; ListNode: prev, curr = None, head while curr: tmp = curr.next curr.next = prev prev, curr = curr, tmp return prev 1234567891011121314151617class ListNode: def ___init___(self, x): self.val = x self.next = Nonedef recursive_reverse_list(head: ListNode) -&gt; ListNode: if not head or not head.next: return head # tail will always be the tail of the whole linked list tail = recursive_reverse_list(head.next) head.next.next = head head.next = None return tail","link":"/wanderland/2019/06/02/leetcode/linked_list/reverse-linked-list/"},{"title":"Sort List","text":"ProblemSort a linked list in O(nlogn) time using constant space complexity. Example 1: 12Input: 4-&gt;2-&gt;1-&gt;3Output: 1-&gt;2-&gt;3-&gt;4 Example 2: 12Input: -1-&gt;5-&gt;3-&gt;4-&gt;0Output: -1-&gt;0-&gt;3-&gt;4-&gt;5 SolutionTo solve this problem in O(nlogn) time complexity, we could use merge sort on linked list. The important part of merge sort is the merge logic in which we will actually solve the Merge Two Sorted Lists problem. 123456789101112131415161718192021222324252627282930313233343536373839404142class ListNode: def __init__(self, x): self.val = x self.next = Nonedef sort_list(head: ListNode) -&gt; ListNode: if not head or head.next: return head prev, slow, fast = None, head, head while fast and fast.next: prev = slow slow = slow.next fast = fast.next.next prev.next = None # break up the list in the middle left, right = head, slow left, right = sort_list(left), sort_list(right) return merge(left, right)def merge(left: ListNode, right: ListNode) -&gt; ListNode: dummy = curr = ListNode(0) while left and right: if left.val &lt;= right.val: curr.next = left left = left.next else: curr.next = right right = right.next curr = curr.next if left: curr.next = left if right: curr.next = right return dummy.next","link":"/wanderland/2019/11/17/leetcode/linked_list/sort-list/"},{"title":"Reverse Linked List II","text":"ProblemReverse a linked list from position m to n. Do it in one-pass. Note: 1 ≤ m ≤ n ≤ length of list. Example: 12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL SolutionsTo reverse part of the linked list, we need to reach the starting node in the reverse zone, and then do the regular reverse action. The last thing we need to do is connecting the intact part with the reversed section. The code clearly shows how. 1234567891011121314151617181920212223242526272829class ListNode: def __init__(self, x): self.val = x self.next = Nonedef reverse_between(head: ListNode, m: int, n: int) -&gt; ListNode: prev = dummy = ListNode(0) dummy.next = head for _ in range(1, m): prev = prev.next m_prev = prev # the last node before the reverse zone m_curr = n_curr = prev.next # the first node in reverse zone n_post = n_curr.next # the first node after the reverse zone for _ range(m, n): temp = n_post.next n_post.next = n_curr n_curr = n_post n_post = temp # 1 -&gt; 2 &lt;-&gt; 3 &lt;- 4 5 # | | | | # m_prev m_curr n_curr n_post m_prev = n_curr m_curr.next = n_post return dummny.next","link":"/wanderland/2019/09/12/leetcode/linked_list/reverse-linked-list-ii/"},{"title":"Swap Nodes in Pairs","text":"ProblemGiven a linked list, swap every two adjacent nodes and return its head.You may not modify the values in the list’s nodes, only nodes itself may be changed. Example: 1Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. SolutionsSince it only requires to swap nodes in pair, we can solve this problem by isolating paired nodes. The iteration will stop when any of the paired nodes is None. 1234567891011121314151617181920class ListNode: def ___init___(self, x): self.val = x self.next = Nonedef swap_pairs(head: ListNode) -&gt; ListNode: dummy = pre = ListNode(0) dummy.next = head while pre.next is not None and pre.next.next is not None: left, right = pre.next, pre.next.next pre.next = right left.next = right.next right.next = left pre = left return dummy.next","link":"/wanderland/2019/06/01/leetcode/linked_list/swap-nodes-in-pairs/"},{"title":"Split Linked List in Parts","text":"ProblemGiven a (singly) linked list with head node root, write a function to split the linked list into k consecutive linked list “parts”. The length of each part should be as equal as possible: no two parts should have a size differing by more than 1. This may lead to some parts being null. The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later. Return a List of ListNode’s representing the linked list parts that are formed. Example 1:12345678Input:root = [1, 2, 3], k = 5Output: [[1],[2],[3],[],[]]Explanation:The input and each element of the output are ListNodes, not arrays.For example, the input root has root.val = 1, root.next.val = 2, \\root.next.next.val = 3, and root.next.next.next = null.The first element output[0] has output[0].val = 1, output[0].next = null.The last element output[4] is null, but it&apos;s string representation as a ListNode is []. Example 2:12345Input: root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]Explanation:The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts. SolutionThe trick is how we iterate to the right head of each separated part of the linked list. We can derive this by using the total length of the list and the number of parts k. The steps to solve this problem: Find the total length of the linked list Calculate how many nodes should be in each part. Every part has n/k elements, except the first n%k parts have an extra one Iterate the linked list based on the step 2 and find the correct head of each part 123456789101112131415161718192021222324252627class ListNode: def __init__(self, x): self.val = x self.next = Nonedef split_list_to_parts(root: ListNode) -&gt; List[ListNode]: n, curr = 0, root while curr: curr = curr.next n += 1 base, extra = divmod(n, k) res = [] curr = root for i in range(k): head = curr for j in range(base + (1 if i &lt; extra else 0) - 1): if curr: curr = curr.next if curr: curr.next, curr = None, curr.next res.append(head) return res","link":"/wanderland/2019/12/07/leetcode/linked_list/split-linked-list-in-parts/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","link":"/wanderland/tags/LeetCode/"},{"name":"Array","slug":"Array","link":"/wanderland/tags/Array/"},{"name":"Hash Table","slug":"Hash-Table","link":"/wanderland/tags/Hash-Table/"},{"name":"Tree","slug":"Tree","link":"/wanderland/tags/Tree/"},{"name":"Two Pointers","slug":"Two-Pointers","link":"/wanderland/tags/Two-Pointers/"},{"name":"Binary Search","slug":"Binary-Search","link":"/wanderland/tags/Binary-Search/"},{"name":"Math","slug":"Math","link":"/wanderland/tags/Math/"},{"name":"Big Manipulation","slug":"Big-Manipulation","link":"/wanderland/tags/Big-Manipulation/"},{"name":"Algorithms","slug":"Algorithms","link":"/wanderland/tags/Algorithms/"},{"name":"Sorting","slug":"Sorting","link":"/wanderland/tags/Sorting/"},{"name":"Github","slug":"Github","link":"/wanderland/tags/Github/"},{"name":"Tools","slug":"Tools","link":"/wanderland/tags/Tools/"},{"name":"Interview","slug":"Interview","link":"/wanderland/tags/Interview/"},{"name":"Learn","slug":"Learn","link":"/wanderland/tags/Learn/"},{"name":"Tutorial","slug":"Tutorial","link":"/wanderland/tags/Tutorial/"},{"name":"Article","slug":"Article","link":"/wanderland/tags/Article/"},{"name":"Stack","slug":"Stack","link":"/wanderland/tags/Stack/"},{"name":"Depth-first Search","slug":"Depth-first-Search","link":"/wanderland/tags/Depth-first-Search/"},{"name":"Linked List","slug":"Linked-List","link":"/wanderland/tags/Linked-List/"},{"name":"Sentinel","slug":"Sentinel","link":"/wanderland/tags/Sentinel/"},{"name":"Sort","slug":"Sort","link":"/wanderland/tags/Sort/"},{"name":"Set","slug":"Set","link":"/wanderland/tags/Set/"},{"name":"Divide and Conquer","slug":"Divide-and-Conquer","link":"/wanderland/tags/Divide-and-Conquer/"},{"name":"Heap","slug":"Heap","link":"/wanderland/tags/Heap/"},{"name":"Interleave","slug":"Interleave","link":"/wanderland/tags/Interleave/"},{"name":"Recursion","slug":"Recursion","link":"/wanderland/tags/Recursion/"}],"categories":[{"name":"Collection","slug":"Collection","link":"/wanderland/categories/Collection/"},{"name":"LeetCode","slug":"LeetCode","link":"/wanderland/categories/LeetCode/"}]}