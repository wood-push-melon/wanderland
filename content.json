{"pages":[{"title":"tags","text":"","link":"/wanderland/tags/index.html"},{"title":"categories","text":"","link":"/wanderland/categories/index.html"}],"posts":[{"title":"Two Sum IV - Input is a BST","text":"ProblemGiven a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target. Example 1: 12345678910Input: 5 / \\ 3 6 / \\ \\2 4 7Target = 9Output: True Example 2: 12345678910Input: 5 / \\ 3 6 / \\ \\2 4 7Target = 28Output: False SolutionsThe solution to this problem is sort of similar to the one in the original Two Sum problem.The only difference is to traversing a Tree instead of an Array. We use BFS to iterate the whole structure, but DFS is completely a feasible alternative too. 12345678910111213141516171819def findTarget(root: 'TreeNode', k: 'int') -&gt; 'bool': if root is None: return False cache = set() queue = [root] while queue: node = queue.pop(0) if k - node.val in cache: return True cache.add(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return False","link":"/wanderland/2019/02/12/2sum-bst/"},{"title":"3 Sum","text":"ProblemGiven an array nums of n integers, are there three elements a, b, c in nums such that a + b + c = 0 ? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: 1234567Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] SolutionTwo pointers strategy comes to help again. We can first sort the input array, and then make use of the solution in 2 sum with sorted input array to solve this 3 sum problem when we fix the first element a. NOTE The problem specifies that no duplicate driplets should appear in the result, so we have to take this in mind. To meet this requirement, moving left and right pointers should be more aggressive, like skipping next element with same value. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647def three_sum(nums: 'List[int]') -&gt; 'List[List[int]]': res = [] n = len(nums) if n &lt; 3: return res nums.sort() # sort the input first for i in range(n-2): # no need to move on if the fixed element is greater than 0 if nums[i] &gt; 0: break # skip elements with same value if i &gt; 0 and nums[i] == nums[i-1]: continue l, r = i + 1, n - 1 while l &lt; r: s = nums[i] + nums[l] + nums[r] if s == 0: res.append([nums[i], nums[l], nums[r]]) l = increment(nums, l, r) r = decrement(nums, l, r) elif s &lt; 0: l = increment(nums, l, r) else: r = decrement(nums, l, r) return res# increment pointer by skipping same-value elementsdef increment(nums, l, r): while l &lt; r and nums[l] == nums[l+1]: l += 1 return l + 1# decrement pointer by skipping same-value elementsdef decrement(nums, l, r): while l &lt; r and nums[r] == nums[r-1]: r -= 1 return r - 1","link":"/wanderland/2019/02/16/3sum/"},{"title":"Two Sum II - Input array is sorted","text":"ProblemGiven an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Note: Your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. Example: 12345Input: numbers = [2,7,11,15], target = 9Output: [1,2]Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2. SolutionsThe key point is to take advantage of sorted array. We can use two pointers strategy or binary search method to solve this problem. Two solutions are shown below respectively. Solution with two pointers is relatively easy to catch, and it should be the first answer you provide in an interview. Two pointer solution: 123456789101112# Solution with two pointersdef twoSum(nums: 'List[int]', target: 'int') -&gt; 'List[int]': lo, hi = 0, len(nums) - 1 while lo &lt; hi: s = nums[lo] + nums[hi] if s == target: return [lo+1, hi+1] elif s &lt; target: lo += 1 else: hi -= 1 Binary search solution: Binary search solution is kind of difficult to understant compared with two pointer one. Basically it uses binary search algorithm to move start or end pointer faster rather than one step in each iteration. It tries to move start to a new position where nums[start] is the first value that nums[start] &gt;= target - nums[end] if the sum is less than target. Similar logic applies to end pointer. In each helper function, we only consider the pointer we care about. 123456789101112131415161718192021222324252627282930313233343536373839404142434445# Solution using binary searchdef twoSum(nums: 'List[int]', target: 'int') -&gt; 'List[int]': start, end = 0, len(nums) - 1 while start &lt; end: s = nums[start] + nums[end] if s == target: return [start+1, end+1] elif s &lt; target: # need to adjust start pointer start = binary_search_start(nums, start, end, target-nums[end]) else: # need to adjust end pointer end = binary_search_end(nums, start, end, target-nums[start])def binary_search_start(nums, start, end, key): ''' Move the start pointer to the position where nums[start] is the first element greater than or equal to the key ''' while start &lt;= end: mid = start + (end - start) // 2 if nums[mid] &lt; key: start = mid + 1 else: end = mid - 1 return startdef binary_search_end(nums, start, end, key): ''' Move the end pointer to the position where nums[end] is the last element less than or equal to the key ''' while start &lt;= end: mid = start + (end - start) // 2 if nums[mid] &gt; key: end = mid - 1 else: start = mid + 1 return end","link":"/wanderland/2019/02/10/2sum-sorted/"},{"title":"3 Sum Closest","text":"ProblemGiven an array nums of n integers and in interger target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example: 123Given array nums = [-1, 2, 1, -4], and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2) SolutionThe solution to this problem is adapted from the solution in 3 Sum, applying the two pointers strategy. Adaptations are straightforward. NOTE: Initially the closest sum should be given a starting value for comparison inside the loop later. Here we start it with the sum of first three elements, which is the minimum sum among all three-element combinations after soring the input array. However, what the closest initially is does not matter. 1234567891011121314151617181920212223242526272829303132333435363738394041def three_sum_closest(nums, target): n = len(nums) if n &lt; 3: return nums.sort() # initialize closest sum closest = nums[0] + nums[1] + nums[2] for i in range(n-2): l , r = i + 1, n - 1 while l &lt; r: s = nums[0] + nums[1] + nums[2] if s == target: return s if abs(s-target) &lt; abs(closest-target): closest = s if s &lt; target: l = increment(nums, l, r) else: r = decrement(nums, l, r) return closestdef increment(nums, l, r): while l &lt; r and nums[l] == nums[l+1]: l += 1 return l + 1def decrement(nums, l, r): while l &lt; r and nums[r] == nums[r-1]: r -= 1 return r - 1","link":"/wanderland/2019/02/18/3sum-closest/"},{"title":"2Sum","text":"ProblemGiven an array of integers, return indices of the two numbers such that they add up to specific target.You may assume that each inpjut would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. SolutionThe key to this problem is using an external hashtable-like data structure to store the iterated element and its idex in the array, and use such storage to see if the counterpart is already in there. NOTE If the length of nums is less than 2, it is not necessary to go ahead It is better to maintain the order in result list 12345678910def two_sum(nums: 'List[int]', target: 'int') -&gt; 'List[int]': if len(nums) &lt; 2: return cache = {} for idx, num in enumerate(nums): if target - num in cache: return [cache.get(target-num), idx] else: cache.update({num: idx})","link":"/wanderland/2019/02/09/2sum/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/wanderland/2018/12/29/hello-world/"},{"title":"4 Sum","text":"ProblemGiven an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b +c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. Example: 12345678Given array nums = [1, 0, -1, 0, -2, 2], and target = 0A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] SolutionThe solution to k-sum can always be decomopsed to 2-sum problem with k-2 loops wrapping. With this strategic template in mind, we can boil down 4-sum problem to the following implementation. 1234567891011121314151617181920212223242526272829303132333435363738394041424344def four_sum(nums: 'List[int]', target: 'int') -&gt; 'List[List[int]]': res = [] n = len(nums) if n &lt; 4: return res nums.sort() for i in range(n-3): if i &gt; 0 and nums[i] == nums[i-1]: continue for j in range(n-2): if j &gt; i+1 and nums[j] == nums[j-1]: continue l, r = j + 1, n - 1 while l &lt; r: s = nums[i] + nums[j] + nums[l] + nums[r] if s == target: res.append([nums[i], nums[j], nums[l], nums[r]) l = increment(nums, l, r) r = decrement(nums, l, r) elif s &lt; target: l = increment(nums, l, r) else: r = decrement(nums, l, r) return resdef increment(nums, l, r): while l &lt; r and nums[l] == nums[l+1]: l += 1 return l + 1def decrement(nums, l, r): while l &lt; r and nums[r] == nums[r-1]: r -= 1 return r - 1 NOTEk-sum problem can be implemented by using recursion. We will add such implementation later.","link":"/wanderland/2019/02/20/4sum/"},{"title":"Add Two Numbers","text":"ProblemYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. Example: 123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807 SolutionsAt the first glance, we need to solve this problem with regular way in math, adding digits at the same position one by one. However, the edge case is that the resulting list may have an extra carry bit. Sentinel strategy is also applied in here. 123456789101112131415161718192021222324class ListNode: def ___init___(self, x): self.val = x self.next = Nonedef add_two_numbers(l1: ListNode, l2: ListNode) -&gt; ListNode: dummy = curr = ListNode(0) carry = 0 while l1 or l2 or carry: if l1: carry += l1.val l1 = l1.next if l2: carry += l2.val l2 = l2.next curr.next = ListNode(carry % 10) curr = curr.next carry //= 10 return dummy.next","link":"/wanderland/2019/05/23/add-two-numbers/"},{"title":"Merge k Sorted Lists","text":"ProblemMerge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Example: 1234567Input:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 SolutionsThis is a perfect case where heap data structure applies. We can construct a mininum heap at the beginning, and put new node into the heap after retrieving the minimum node each time. Note Pyhton 3 has different implementation in PriorityQueue module. Dealing with tasks with same priority, we have to put some element to keep the stability. I use timestamp in here. 1234567891011121314151617181920212223242526import timefrom queue import PriorityQueueclass ListNode: def ___init___(self, x): self.val = x self.next = Nonedef merge_k_lists(lists: List[ListNode]) -&gt; ListNode: q = PriorityQueue() for l in lists: if l: q.put((l.val, time.time(), l)) dummy = curr = ListNode(0) while not q.empty(): val, _, node = q.get() curr.next = node curr = curr.next node = node.next if node: q.put((node.val, time.time(), node)) return dummy.next","link":"/wanderland/2019/05/29/merge-k-lists/"},{"title":"Remove Nth Node From End of List","text":"ProblemGiven a linked list, remove the n-th node from the end of list and return its head. Example: 12Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. SolutionsThis problem is a perfect match for two pointer strategy. But in this case, we don’t declare slow and fast starting at the same position because we need to think about the edge case: when the removed node is head node. Note We use range to form a loop whenever possible because range is implemented in C language at the bottom. 1234567891011121314151617181920class ListNode: def ___init___(self, x): self.val = x self.next = Nonedef remove_nth_from_end(head: ListNode, n: int) -&gt; ListNode: slow = dummy = ListNode(0) dummy.next = fast = head for _ in range(n): fast = fast.next while fast: slow = slow.next fast = fast.next slow.next = slow.next.next return dummy.next","link":"/wanderland/2019/05/30/remove-nth-node-from-end/"},{"title":"Palindrome Number","text":"ProblemDetermine whether an integer is a palindrome. An integer is palindrome when it reads the same backward as forward. Example: 12Input: 121Output: true Example: 123Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. SolutionThe first solution coming intuitively is to convert the input to string, and then easily compare the str(input) with reverse(str(input)). NOTE As for Python, we don’t have the risk of being overflowed for int type, since the memory is allocated dynamically. The int object could be infinitely large theoretically. 12def is_palindrome(x: int) -&gt; bool: return str(x) == str(x)[::-1] The second way to address this problem is just following pure math. 12345678910def is_palindrome(x: int) -&gt; bool: if x &lt; 0: return False rev, tmp = 0, x while tmp: rev = rev * 10 + tmp % 10 tmp = tmp // 10 return rev == x","link":"/wanderland/2019/03/08/palindrome-number/"},{"title":"Swap Nodes in Pairs","text":"ProblemGiven a linked list, swap every two adjacent nodes and return its head.You may not modify the values in the list’s nodes, only nodes itself may be changed. Example: 1Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. SolutionsSince it only requires to swap nodes in pair, we can solve this problem by isolating paired nodes. The iteration will stop when any of the paired nodes is None. 1234567891011121314151617181920class ListNode: def ___init___(self, x): self.val = x self.next = Nonedef swap_pairs(head: ListNode) -&gt; ListNode: dummy = pre = ListNode(0) dummy.next = head while pre.next is not None and pre.next.next is not None: left, right = pre.next, pre.next.next pre.next = right left.next = right.next right.next = left pre = left return dummy.next","link":"/wanderland/2019/06/01/swap-nodes-in-pairs/"},{"title":"Power of Two","text":"ProblemGiven an integer, write a function to determine if it is a power of two. Example: 123Input: 1Output: trueExplanation: 2^0 = 1 Example: 123Input: 16Output: trueExplanation: 2^4 = 16 SolutionWe of course can follow the intuitive way to judge if the input is a power of two. But LeetCode gave me a 「Time Limit Exceeded」… Anyway, this method also suits Power of Three and Power of Four. 12345678def is_power_of_two(n: int) -&gt; bool: if n &lt;= 0: return False while not n % 2: n = n // 2 return n == 1 Another try goes to recursion. 12def is_power_of_two(n: int) -&gt; bool: return n &gt; 0 and ( n == 1 or ( n % 2 == 0 and isPowerOfTwo(n//2) ) ) Bit manipulation solution is a little bit tricky at first glance. it works based on the fact that n &amp; (n-1) == 0 if n is a power of two. Example: 123a = 16 which is 0b10000b = 15 which is 0b01111a &amp; b = 0 12345def is_power_of_two(n: int) -&gt; bool: if n &lt;= 0: return False return not (n &amp; (n-1) )","link":"/wanderland/2019/03/08/power-of-two/"},{"title":"Sorting Algorithms","text":"This post is aim to summerize a handful of fundamental sorting algoritms that one should be very familiar with. Bubble SortIt compares adjacent two elements in the input array to check if a swap is needed. The right half section is sorted.Time complexity is O(n^2).It is stable. 1234567891011121314def bubble_sort(seq): n = len(seq) if n &lt; 2 return for i in range(n): flag = False for j in range(n - i - 1): if seq[j] &gt; seq[j+1]: seq[j], seq[j+1] = seq[j+1], seq[j] flag = True if flag is False: break Insertion SortIt divides the input sequence into two parts: sorted and unsorted sections. Unsorted section starts from i to the end.It compares the first element seq[i] in unsorted section with element seq[j] in sorted part in reverse order step by step by moving sorted elements until a proper location is found.Time complexity is O(n^2).It is stable. 12345678910111213def insertion_sort(seq): n = len(seq) if n &lt; 2 return for i in range(1, n): value = seq[i] j = i - 1 while j &gt;= 0 and seq[j] &gt; value: seq[j+1] = seq[j] j -= 1 seq[j+1] = value Selection SortSimilarly, it divides the input into sorted and unsorted parts. It picks minimum value seq[min_idx] at each iteration to swap with head element seq[i] in the unsorted section.Time complexity is O(n^2).It is NOT stable. 12345678910111213def selection_sort(seq): n = len(seq) if n &lt; 2: return for i in range(n): min_idx = i for j in range(i+1, n): if seq[j] &lt; seq[min_idx]: min_idx = j if min_idx != i: seq[i], seq[min_idx] = seq[min_idx], seq[i] Merge SortIt at the beginning divides the input array recursively, and later rebuild it by merging two parts in ascending order. The merge implementation is the hinge.Time complexity is O(nlogn).It is stable. Recursion equation:1234merge_sort(l...r) = merge(merge_sort(l...m), merge(m+1...r))it terminates when:l &gt;= r 123456789101112131415161718192021222324252627282930def merge_sort(seq): sort(seq, 0, len(seq)-1)def sort(seq, l, r): if l &gt;= r: return m = l + (r - l) // 2 sort(seq, l, m) sort(seq, m+1, r) merge(seq, l, m, r)def merge(seq, l, m, r): i, j = l, m+1 tmp = [] while i &lt;= m and j &lt;= r: if seq[i] &lt;= seq[j]: tmp.append(seq[i]) i += 1 else: tmp.append(seq[j]) j += 1 start = i if i &lt;= m else j end = m if i &lt;= m else r tmp.extend(seq[start:end]) seq[:] = tmp Quick SortThe key is all about partition implementation. It picks the last element as pivot to make sure all elements before the pivot are less than it, and elements after it are greater.Time complexity is O(nlogn).It is NOT stable. Recursion equation:1234quick_sort(l...r) = quick_sort(l...p-1) + quick_sort(p+1...r)it terminates when:l &gt;= r 123456789101112131415161718192021222324def quick_sort(seq): sort(seq, 0, len(seq) - 1)def sort(seq, l, r): if l &gt;= r: return pivot = partition(seq, l, r) sort(seq, l, pivot-1) sort(seq, pivot+1, r)def partition(seq, l, r): pivot = seq[r] i = l for j in range(l, r): if seq[j] &lt; pivot: seq[i], seq[j] = seq[j], seq[i] i += 1 seq[i], seq[r] = seq[r], seq[i] return i Heap SortHeap Sort continuously swaps the top element (the maximum) with the last element in the heap, and build the heap again.Time complexity is O(nlogn).It is NOT stable. 12345678910111213141516171819202122232425262728293031323334353637def heap_sort(seq): build_heap(seq) heap_size = len(seq) - 1 for last in range(heap_size, 0, -1): seq[0], seq[last] = seq[last], seq[0] heap_size -= 1 heapify(seq, 0, heap_size) return seqdef build_heap(seq): ''' Only necessary to build heap from 0 to n // 2 because leaf nodes start from n // 2 + 1 ''' n = len(seq) - 1 for i in range(n // 2, -1, -1): heapify(seq, i, n)def heapify(seq, i, n): while True: l, r = 2 * i + 1, 2 * i + 2 max_idx = i if l &lt;= n and seq[i] &lt; seq[l]: max_idx = l if r &lt;= n and seq[max_idx] &lt; seq[r]: max_idx = r if max_idx == i: break seq[i], seq[max_idx] = seq[max_idx], seq[i] i = max_idx SummaryMerge Sort and Quick Sort are based on Divide and Conquer strategy. They are capable of sorting large-scale data, while others left are supposed to sort data in musch smaller size. Even though having the same time complexity, Heap Sort is not superior to Quick Sort. Heap Sort needs more swap processes, and heapify procedure does not access data in the array sequentially, unfriendly to CPU cache.","link":"/wanderland/2019/02/14/sorting/"},{"title":"一些有趣的文章","text":"原理 只有 13 台 DNS 根域名服务器的原因此文解释了为什么 DNS 根域名服务器只有 13 个 IP 的原因 如何用 Python 实现一个简单的 JSON 解析器此文描述了使用 Python 如何实现一个简单的 JSON Parser，主要体现在词法分析 (lexical) 和语法分析 (syntactic) 两个步骤 Python Pragmatic UnicodeUnicode in Python2 and Python3 Unicode &amp; Character Encodings in Python: A Painless Guide解释了什么是 Character Encoding 以及 Unicode。全面介绍了 Python3 中 Unicode encoding 和 decoding Python PattensPython 语言中的设计模式 Things you’re probably not using in Python 3 - but should介绍了 Python 3 中的一些 features Linux Linux: a Portable Operating System大神 Linus Torvalds 当年的硕士毕业论文，介绍 Linux 系统如何适配不同的硬件架构 前端 如何编写深色主题的 CSS本文介绍了 Yandex Mail 团队如何使用 CSS 代码实现 APP 上的深色主题 设计 非设计师需要知道的设计原则本文介绍了四个简单基本的设计原则给非设计人员","link":"/wanderland/2019/06/02/articles/articles/"},{"title":"一些有用的工具以及资源","text":"组件库 ui-libraries收集了前端各种 UI 组件库 Semiotic一款 React 的数据可视化框架，很漂亮简洁 图标 ikonate开源的一套 SVG 图标 图片 Upsplash免费的高清图片网站 Cool Backgrounds自动生成背景图片的网站 CSS CSS Gradient提供定制化的 CSS Gradient 样式 Mac App Winds一款开源的 RSS 阅读和 Podcast APP","link":"/wanderland/2019/06/02/articles/tools/"},{"title":"Reverse Nodes in k-Group","text":"ProblemGiven a linked list, reverse the nodes of a linked list k at a time and return its modified list.k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. Example: 12345Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 Note: Only constant extra memory is allowed. You may not alter the values in the list’s nodes, only nodes itself may be changed. SolutionsWe can use the solution in Reverse Linked List to reverse each group of the list. And then connect the tail of previous reversed part with the head of the next reversed part. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from typing import Tupleclass ListNode: def ___init___(self, x): self.val = x self.next = Nonedef reverse_k_group(head, k): \"\"\" Inside each call stack: - try to iterate k times to check if there are enough k nodes to reverse - reverse k nodes starting from the head of current group - connect the head (which is the tail after reversed) of the current group with the head of the next reversed k-node group - return the head of current reversed group \"\"\" count, curr = 0, head while count &lt; k and curr: curr = curr.next count += 1 if count &lt; k: return head prev, nxt_head = reverse(head, k) head.next = reverse_k_group(nxt_head, k) return prevdef reverse(head: ListNode, k: int) -&gt; Tuple[ListNode, ListNode]: \"\"\" Reverse a single group of nodes For example: k = 3 Before: prev curr | | 1 -&gt; 2 -&gt; 3 -&gt; 4 After: prev curr | | 1 &lt;- 2 &lt;- 3 -&gt; 4 \"\"\" prev, curr = None, head for i in range(count): tmp = curr.next curr.next = prev prev = curr curr = tmp return prev, curr","link":"/wanderland/2019/06/02/reverse-nodes-k-group/"},{"title":"学习资源","text":"设计模式 Design Pattens for Humans Python Pattens 系统设计 Grokking the System Design Interview","link":"/wanderland/2019/04/14/articles/learn-resource/"},{"title":"Reverse Linked List","text":"ProblemReverse a singly linked list. Example: 12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both? SolutionsThe iterative solution is relatively straightforward by flipping the current node’s next pointer. But recursive solution is slightly trickier. We need to think about it backwards. Assume from node n(k+1) to n(m) has been reversed and we are at node n(k). 1n(1) -&gt; ... -&gt; n(k-1) -&gt; n(k) -&gt; n(k+1) &lt;- ... &lt;- n(m) We want n(k+1)’s next node point to n(k). So we need to do 12n(k).next.next = n(k)n(k).next = NULL Don’t forget that we need to pop up the tail as the final result. 12345678910111213141516class ListNode: def ___init___(self, x): self.val = x self.next = Nonedef reverse_list(head: ListNode) -&gt; ListNode: prev, curr = None, head while curr: tmp = curr.next curr.next = prev prev, curr = curr, tmp return prev 1234567891011121314151617class ListNode: def ___init___(self, x): self.val = x self.next = Nonedef recursive_reverse_list(head: ListNode) -&gt; ListNode: if not head or not head.next: return head # tail will always be the tail of the whole linked list tail = recursive_reverse_list(head.next) head.next.next = head head.next = None return tail","link":"/wanderland/2019/06/02/reverse-linked-list/"},{"title":"教程类文章","text":"Docker Dockerizing a React AppReact 应用的 Docker 化。文中介绍了如何将 React 应用打包成生产环境可用的容器 Python 如何用 Python 实现一个简单的 JSON 解析器此文描述了使用 Python 如何实现一个简单的 JSON Parser，主要体现在词法分析 (lexical) 和语法分析 (syntactic) 两个步骤 前端CSS 如何编写深色主题的 CSS本文介绍了 Yandex Mail 团队如何使用 CSS 代码实现 APP 上的深色主题 Design 非设计师需要知道的设计原则本文介绍了四个简单基本的设计原则给非设计人员","link":"/wanderland/2019/06/16/articles/tutorials/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","link":"/wanderland/tags/LeetCode/"},{"name":"Array","slug":"Array","link":"/wanderland/tags/Array/"},{"name":"Hash Table","slug":"Hash-Table","link":"/wanderland/tags/Hash-Table/"},{"name":"Tree","slug":"Tree","link":"/wanderland/tags/Tree/"},{"name":"Two Pointers","slug":"Two-Pointers","link":"/wanderland/tags/Two-Pointers/"},{"name":"Binary Search","slug":"Binary-Search","link":"/wanderland/tags/Binary-Search/"},{"name":"Linked List","slug":"Linked-List","link":"/wanderland/tags/Linked-List/"},{"name":"Sentinel","slug":"Sentinel","link":"/wanderland/tags/Sentinel/"},{"name":"Math","slug":"Math","link":"/wanderland/tags/Math/"},{"name":"Divide and Conquer","slug":"Divide-and-Conquer","link":"/wanderland/tags/Divide-and-Conquer/"},{"name":"Heap","slug":"Heap","link":"/wanderland/tags/Heap/"},{"name":"Learn","slug":"Learn","link":"/wanderland/tags/Learn/"},{"name":"Big Manipulation","slug":"Big-Manipulation","link":"/wanderland/tags/Big-Manipulation/"},{"name":"Algorithms","slug":"Algorithms","link":"/wanderland/tags/Algorithms/"},{"name":"Sorting","slug":"Sorting","link":"/wanderland/tags/Sorting/"},{"name":"Article","slug":"Article","link":"/wanderland/tags/Article/"},{"name":"Tools","slug":"Tools","link":"/wanderland/tags/Tools/"},{"name":"Recursion","slug":"Recursion","link":"/wanderland/tags/Recursion/"},{"name":"Tutorial","slug":"Tutorial","link":"/wanderland/tags/Tutorial/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","link":"/wanderland/categories/LeetCode/"},{"name":"Collection","slug":"Collection","link":"/wanderland/categories/Collection/"}]}