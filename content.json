{"pages":[{"title":"tags","text":"","link":"/wanderland/tags/index.html"},{"title":"categories","text":"","link":"/wanderland/categories/index.html"}],"posts":[{"title":"Two Sum II - Input array is sorted","text":"ProblemGiven an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Note: Your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. Example: 12345Input: numbers = [2,7,11,15], target = 9Output: [1,2]Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2. SolutionsThe key point is to take advantage of sorted array. We can use two pointers strategy or binary search method to solve this problem. Two solutions are shown below respectively. Solution with two pointers is relatively easy to catch, and it should be the first answer you provide in an interview. Two pointer solution: 123456789101112# Solution with two pointersdef twoSum(nums: 'List[int]', target: 'int') -&gt; 'List[int]': lo, hi = 0, len(nums) - 1 while lo &lt; hi: s = nums[lo] + nums[hi] if s == target: return [lo+1, hi+1] elif s &lt; target: lo += 1 else: hi -= 1 Binary search solution: Binary search solution is kind of difficult to understant compared with two pointer one. Basically it uses binary search algorithm to move start or end pointer faster rather than one step in each iteration. It tries to move start to a new position where nums[start] is the first value that nums[start] &gt;= target - nums[end] if the sum is less than target. Similar logic applies to end pointer. In each helper function, we only consider the pointer we care about. 123456789101112131415161718192021222324252627282930313233343536373839404142434445# Solution using binary searchdef twoSum(nums: 'List[int]', target: 'int') -&gt; 'List[int]': start, end = 0, len(nums) - 1 while start &lt; end: s = nums[start] + nums[end] if s == target: return [start+1, end+1] elif s &lt; target: # need to adjust start pointer start = binary_search_start(nums, start, end, target-nums[end]) else: # need to adjust end pointer end = binary_search_end(nums, start, end, target-nums[start])def binary_search_start(nums, start, end, key): ''' Move the start pointer to the position where nums[start] is the first element greater than or equal to the key ''' while start &lt;= end: mid = start + (end - start) // 2 if nums[mid] &lt; key: start = mid + 1 else: end = mid - 1 return startdef binary_search_end(nums, start, end, key): ''' Move the end pointer to the position where nums[end] is the last element less than or equal to the key ''' while start &lt;= end: mid = start + (end - start) // 2 if nums[mid] &gt; key: end = mid - 1 else: start = mid + 1 return end","link":"/wanderland/2019/02/10/2sum-sorted/"},{"title":"Two Sum IV - Input is a BST","text":"ProblemGiven a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target. Example 1: 12345678910Input: 5 / \\ 3 6 / \\ \\2 4 7Target = 9Output: True Example 2: 12345678910Input: 5 / \\ 3 6 / \\ \\2 4 7Target = 28Output: False SolutionsThe solution to this problem is sort of similar to the one in the original Two Sum problem.The only difference is to traversing a Tree instead of an Array. We use BFS to iterate the whole structure, but DFS is completely a feasible alternative too. 12345678910111213141516171819def findTarget(root: 'TreeNode', k: 'int') -&gt; 'bool': if root is None: return False cache = set() queue = [root] while queue: node = queue.pop(0) if k - node.val in cache: return True cache.add(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return False","link":"/wanderland/2019/02/12/2sum-bst/"},{"title":"2Sum","text":"ProblemGiven an array of integers, return indices of the two numbers such that they add up to specific target.You may assume that each inpjut would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. SolutionThe key to this problem is using an external hashtable-like data structure to store the iterated element and its idex in the array, and use such storage to see if the counterpart is already in there. NOTE If the length of nums is less than 2, it is not necessary to go ahead It is better to maintain the order in result list 12345678910def two_sum(nums: 'List[int]', target: 'int') -&gt; 'List[int]': if len(nums) &lt; 2: return cache = {} for idx, num in enumerate(nums): if target - num in cache: return [cache.get(target-num), idx] else: cache.update({num: idx})","link":"/wanderland/2019/02/09/2sum/"},{"title":"3 Sum Closest","text":"ProblemGiven an array nums of n integers and in interger target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example: 123Given array nums = [-1, 2, 1, -4], and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2) SolutionThe solution to this problem is adapted from the solution in 3 Sum, applying the two pointers strategy. Adaptations are straightforward. NOTE: Initially the closest sum should be given a starting value for comparison inside the loop later. Here we start it with the sum of first three elements, which is the minimum sum among all three-element combinations after soring the input array. However, what the closest initially is does not matter. 1234567891011121314151617181920212223242526272829303132333435363738394041def three_sum_closest(nums, target): n = len(nums) if n &lt; 3: return nums.sort() # initialize closest sum closest = nums[0] + nums[1] + nums[2] for i in range(n-2): l , r = i + 1, n - 1 while l &lt; r: s = nums[0] + nums[1] + nums[2] if s == target: return s if abs(s-target) &lt; abs(closest-target): closest = s if s &lt; target: l = increment(nums, l, r) else: r = decrement(nums, l, r) return closestdef increment(nums, l, r): while l &lt; r and nums[l] == nums[l+1]: l += 1 return l + 1def decrement(nums, l, r): while l &lt; r and nums[r] == nums[r-1]: r -= 1 return r - 1","link":"/wanderland/2019/02/18/3sum-closest/"},{"title":"Add Two Numbers","text":"ProblemYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. Example: 123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807 SolutionsAt the first glance, we need to solve this problem with regular way in math, adding digits at the same position one by one. However, the edge case is that the resulting list may have an extra carry bit. Sentinel strategy is also applied in here. 123456789101112131415161718192021222324class ListNode: def ___init___(self, x): self.val = x self.next = Nonedef add_two_numbers(l1: ListNode, l2: ListNode) -&gt; ListNode: dummy = curr = ListNode(0) carry = 0 while l1 or l2 or carry: if l1: carry += l1.val l1 = l1.next if l2: carry += l2.val l2 = l2.next curr.next = ListNode(carry % 10) curr = curr.next carry //= 10 return dummy.next","link":"/wanderland/2019/05/23/add-two-numbers/"},{"title":"4 Sum","text":"ProblemGiven an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b +c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. Example: 12345678Given array nums = [1, 0, -1, 0, -2, 2], and target = 0A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] SolutionThe solution to k-sum can always be decomopsed to 2-sum problem with k-2 loops wrapping. With this strategic template in mind, we can boil down 4-sum problem to the following implementation. 1234567891011121314151617181920212223242526272829303132333435363738394041424344def four_sum(nums: 'List[int]', target: 'int') -&gt; 'List[List[int]]': res = [] n = len(nums) if n &lt; 4: return res nums.sort() for i in range(n-3): if i &gt; 0 and nums[i] == nums[i-1]: continue for j in range(n-2): if j &gt; i+1 and nums[j] == nums[j-1]: continue l, r = j + 1, n - 1 while l &lt; r: s = nums[i] + nums[j] + nums[l] + nums[r] if s == target: res.append([nums[i], nums[j], nums[l], nums[r]) l = increment(nums, l, r) r = decrement(nums, l, r) elif s &lt; target: l = increment(nums, l, r) else: r = decrement(nums, l, r) return resdef increment(nums, l, r): while l &lt; r and nums[l] == nums[l+1]: l += 1 return l + 1def decrement(nums, l, r): while l &lt; r and nums[r] == nums[r-1]: r -= 1 return r - 1 NOTEk-sum problem can be implemented by using recursion. We will add such implementation later.","link":"/wanderland/2019/02/20/4sum/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/wanderland/2018/12/29/hello-world/"},{"title":"3 Sum","text":"ProblemGiven an array nums of n integers, are there three elements a, b, c in nums such that a + b + c = 0 ? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: 1234567Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] SolutionTwo pointers strategy comes to help again. We can first sort the input array, and then make use of the solution in 2 sum with sorted input array to solve this 3 sum problem when we fix the first element a. NOTE The problem specifies that no duplicate driplets should appear in the result, so we have to take this in mind. To meet this requirement, moving left and right pointers should be more aggressive, like skipping next element with same value. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647def three_sum(nums: 'List[int]') -&gt; 'List[List[int]]': res = [] n = len(nums) if n &lt; 3: return res nums.sort() # sort the input first for i in range(n-2): # no need to move on if the fixed element is greater than 0 if nums[i] &gt; 0: break # skip elements with same value if i &gt; 0 and nums[i] == nums[i-1]: continue l, r = i + 1, n - 1 while l &lt; r: s = nums[i] + nums[l] + nums[r] if s == 0: res.append([nums[i], nums[l], nums[r]]) l = increment(nums, l, r) r = decrement(nums, l, r) elif s &lt; 0: l = increment(nums, l, r) else: r = decrement(nums, l, r) return res# increment pointer by skipping same-value elementsdef increment(nums, l, r): while l &lt; r and nums[l] == nums[l+1]: l += 1 return l + 1# decrement pointer by skipping same-value elementsdef decrement(nums, l, r): while l &lt; r and nums[r] == nums[r-1]: r -= 1 return r - 1","link":"/wanderland/2019/02/16/3sum/"},{"title":"Merge k Sorted Lists","text":"ProblemMerge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Example: 1234567Input:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 SolutionsThis is a perfect case where heap data structure applies. We can construct a mininum heap at the beginning, and put new node into the heap after retrieving the minimum node each time. Note Pyhton 3 has different implementation in PriorityQueue module. Dealing with tasks with same priority, we have to put some element to keep the stability. I use timestamp in here. 1234567891011121314151617181920212223242526import timefrom queue import PriorityQueueclass ListNode: def ___init___(self, x): self.val = x self.next = Nonedef merge_k_lists(lists: List[ListNode]) -&gt; ListNode: q = PriorityQueue() for l in lists: if l: q.put((l.val, time.time(), l)) dummy = curr = ListNode(0) while not q.empty(): val, _, node = q.get() curr.next = node curr = curr.next node = node.next if node: q.put((node.val, time.time(), node)) return dummy.next","link":"/wanderland/2019/05/29/merge-k-lists/"},{"title":"Palindrome Number","text":"ProblemDetermine whether an integer is a palindrome. An integer is palindrome when it reads the same backward as forward. Example: 12Input: 121Output: true Example: 123Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. SolutionThe first solution coming intuitively is to convert the input to string, and then easily compare the str(input) with reverse(str(input)). NOTE As for Python, we don’t have the risk of being overflowed for int type, since the memory is allocated dynamically. The int object could be infinitely large theoretically. 12def is_palindrome(x: int) -&gt; bool: return str(x) == str(x)[::-1] The second way to address this problem is just following pure math. 12345678910def is_palindrome(x: int) -&gt; bool: if x &lt; 0: return False rev, tmp = 0, x while tmp: rev = rev * 10 + tmp % 10 tmp = tmp // 10 return rev == x","link":"/wanderland/2019/03/08/palindrome-number/"},{"title":"Power of Two","text":"ProblemGiven an integer, write a function to determine if it is a power of two. Example: 123Input: 1Output: trueExplanation: 2^0 = 1 Example: 123Input: 16Output: trueExplanation: 2^4 = 16 SolutionWe of course can follow the intuitive way to judge if the input is a power of two. But LeetCode gave me a 「Time Limit Exceeded」… Anyway, this method also suits Power of Three and Power of Four. 12345678def is_power_of_two(n: int) -&gt; bool: if n &lt;= 0: return False while not n % 2: n = n // 2 return n == 1 Another try goes to recursion. 12def is_power_of_two(n: int) -&gt; bool: return n &gt; 0 and ( n == 1 or ( n % 2 == 0 and isPowerOfTwo(n//2) ) ) Bit manipulation solution is a little bit tricky at first glance. it works based on the fact that n &amp; (n-1) == 0 if n is a power of two. Example: 123a = 16 which is 0b10000b = 15 which is 0b01111a &amp; b = 0 12345def is_power_of_two(n: int) -&gt; bool: if n &lt;= 0: return False return not (n &amp; (n-1) )","link":"/wanderland/2019/03/08/power-of-two/"},{"title":"Reverse Linked List","text":"ProblemReverse a singly linked list. Example: 12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both? SolutionsThe iterative solution is relatively straightforward by flipping the current node’s next pointer. But recursive solution is slightly trickier. We need to think about it backwards. Assume from node n(k+1) to n(m) has been reversed and we are at node n(k). 1n(1) -&gt; ... -&gt; n(k-1) -&gt; n(k) -&gt; n(k+1) &lt;- ... &lt;- n(m) We want n(k+1)’s next node point to n(k). So we need to do 12n(k).next.next = n(k)n(k).next = NULL Don’t forget that we need to pop up the tail as the final result. 12345678910111213141516class ListNode: def ___init___(self, x): self.val = x self.next = Nonedef reverse_list(head: ListNode) -&gt; ListNode: prev, curr = None, head while curr: tmp = curr.next curr.next = prev prev, curr = curr, tmp return prev 1234567891011121314151617class ListNode: def ___init___(self, x): self.val = x self.next = Nonedef recursive_reverse_list(head: ListNode) -&gt; ListNode: if not head or not head.next: return head # tail will always be the tail of the whole linked list tail = recursive_reverse_list(head.next) head.next.next = head head.next = None return tail","link":"/wanderland/2019/06/02/reverse-linked-list/"},{"title":"Remove Nth Node From End of List","text":"ProblemGiven a linked list, remove the n-th node from the end of list and return its head. Example: 12Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. SolutionsThis problem is a perfect match for two pointer strategy. But in this case, we don’t declare slow and fast starting at the same position because we need to think about the edge case: when the removed node is head node. Note We use range to form a loop whenever possible because range is implemented in C language at the bottom. 1234567891011121314151617181920class ListNode: def ___init___(self, x): self.val = x self.next = Nonedef remove_nth_from_end(head: ListNode, n: int) -&gt; ListNode: slow = dummy = ListNode(0) dummy.next = fast = head for _ in range(n): fast = fast.next while fast: slow = slow.next fast = fast.next slow.next = slow.next.next return dummy.next","link":"/wanderland/2019/05/30/remove-nth-node-from-end/"},{"title":"Reverse Nodes in k-Group","text":"ProblemGiven a linked list, reverse the nodes of a linked list k at a time and return its modified list.k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. Example: 12345Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 Note: Only constant extra memory is allowed. You may not alter the values in the list’s nodes, only nodes itself may be changed. SolutionsWe can use the solution in Reverse Linked List to reverse each group of the list. And then connect the tail of previous reversed part with the head of the next reversed part. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from typing import Tupleclass ListNode: def ___init___(self, x): self.val = x self.next = Nonedef reverse_k_group(head, k): \"\"\" Inside each call stack: - try to iterate k times to check if there are enough k nodes to reverse - reverse k nodes starting from the head of current group - connect the head (which is the tail after reversed) of the current group with the head of the next reversed k-node group - return the head of current reversed group \"\"\" count, curr = 0, head while count &lt; k and curr: curr = curr.next count += 1 if count &lt; k: return head prev, nxt_head = reverse(head, k) head.next = reverse_k_group(nxt_head, k) return prevdef reverse(head: ListNode, k: int) -&gt; Tuple[ListNode, ListNode]: \"\"\" Reverse a single group of nodes For example: k = 3 Before: prev curr | | 1 -&gt; 2 -&gt; 3 -&gt; 4 After: prev curr | | 1 &lt;- 2 &lt;- 3 -&gt; 4 \"\"\" prev, curr = None, head for i in range(count): tmp = curr.next curr.next = prev prev = curr curr = tmp return prev, curr","link":"/wanderland/2019/06/02/reverse-nodes-k-group/"},{"title":"Sorting Algorithms","text":"This post is aim to summerize a handful of fundamental sorting algoritms that one should be very familiar with. Bubble SortIt compares adjacent two elements in the input array to check if a swap is needed. The right half section is sorted.Time complexity is O(n^2).It is stable. 1234567891011121314def bubble_sort(seq): n = len(seq) if n &lt; 2 return for i in range(n): flag = False for j in range(n - i - 1): if seq[j] &gt; seq[j+1]: seq[j], seq[j+1] = seq[j+1], seq[j] flag = True if flag is False: break Insertion SortIt divides the input sequence into two parts: sorted and unsorted sections. Unsorted section starts from i to the end.It compares the first element seq[i] in unsorted section with element seq[j] in sorted part in reverse order step by step by moving sorted elements until a proper location is found.Time complexity is O(n^2).It is stable. 12345678910111213def insertion_sort(seq): n = len(seq) if n &lt; 2 return for i in range(1, n): value = seq[i] j = i - 1 while j &gt;= 0 and seq[j] &gt; value: seq[j+1] = seq[j] j -= 1 seq[j+1] = value Selection SortSimilarly, it divides the input into sorted and unsorted parts. It picks minimum value seq[min_idx] at each iteration to swap with head element seq[i] in the unsorted section.Time complexity is O(n^2).It is NOT stable. 12345678910111213def selection_sort(seq): n = len(seq) if n &lt; 2: return for i in range(n): min_idx = i for j in range(i+1, n): if seq[j] &lt; seq[min_idx]: min_idx = j if min_idx != i: seq[i], seq[min_idx] = seq[min_idx], seq[i] Merge SortIt at the beginning divides the input array recursively, and later rebuild it by merging two parts in ascending order. The merge implementation is the hinge.Time complexity is O(nlogn).It is stable. Recursion equation:1234merge_sort(l...r) = merge(merge_sort(l...m), merge(m+1...r))it terminates when:l &gt;= r 123456789101112131415161718192021222324252627282930def merge_sort(seq): sort(seq, 0, len(seq)-1)def sort(seq, l, r): if l &gt;= r: return m = l + (r - l) // 2 sort(seq, l, m) sort(seq, m+1, r) merge(seq, l, m, r)def merge(seq, l, m, r): i, j = l, m+1 tmp = [] while i &lt;= m and j &lt;= r: if seq[i] &lt;= seq[j]: tmp.append(seq[i]) i += 1 else: tmp.append(seq[j]) j += 1 start = i if i &lt;= m else j end = m if i &lt;= m else r tmp.extend(seq[start:end]) seq[:] = tmp Quick SortThe key is all about partition implementation. It picks the last element as pivot to make sure all elements before the pivot are less than it, and elements after it are greater.Time complexity is O(nlogn).It is NOT stable. Recursion equation:1234quick_sort(l...r) = quick_sort(l...p-1) + quick_sort(p+1...r)it terminates when:l &gt;= r 123456789101112131415161718192021222324def quick_sort(seq): sort(seq, 0, len(seq) - 1)def sort(seq, l, r): if l &gt;= r: return pivot = partition(seq, l, r) sort(seq, l, pivot-1) sort(seq, pivot+1, r)def partition(seq, l, r): pivot = seq[r] i = l for j in range(l, r): if seq[j] &lt; pivot: seq[i], seq[j] = seq[j], seq[i] i += 1 seq[i], seq[r] = seq[r], seq[i] return i Heap SortHeap Sort continuously swaps the top element (the maximum) with the last element in the heap, and build the heap again.Time complexity is O(nlogn).It is NOT stable. 12345678910111213141516171819202122232425262728293031323334353637def heap_sort(seq): build_heap(seq) heap_size = len(seq) - 1 for last in range(heap_size, 0, -1): seq[0], seq[last] = seq[last], seq[0] heap_size -= 1 heapify(seq, 0, heap_size) return seqdef build_heap(seq): ''' Only necessary to build heap from 0 to n // 2 because leaf nodes start from n // 2 + 1 ''' n = len(seq) - 1 for i in range(n // 2, -1, -1): heapify(seq, i, n)def heapify(seq, i, n): while True: l, r = 2 * i + 1, 2 * i + 2 max_idx = i if l &lt;= n and seq[i] &lt; seq[l]: max_idx = l if r &lt;= n and seq[max_idx] &lt; seq[r]: max_idx = r if max_idx == i: break seq[i], seq[max_idx] = seq[max_idx], seq[i] i = max_idx SummaryMerge Sort and Quick Sort are based on Divide and Conquer strategy. They are capable of sorting large-scale data, while others left are supposed to sort data in musch smaller size. Even though having the same time complexity, Heap Sort is not superior to Quick Sort. Heap Sort needs more swap processes, and heapify procedure does not access data in the array sequentially, unfriendly to CPU cache.","link":"/wanderland/2019/02/14/sorting/"},{"title":"Swap Nodes in Pairs","text":"ProblemGiven a linked list, swap every two adjacent nodes and return its head.You may not modify the values in the list’s nodes, only nodes itself may be changed. Example: 1Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. SolutionsSince it only requires to swap nodes in pair, we can solve this problem by isolating paired nodes. The iteration will stop when any of the paired nodes is None. 1234567891011121314151617181920class ListNode: def ___init___(self, x): self.val = x self.next = Nonedef swap_pairs(head: ListNode) -&gt; ListNode: dummy = pre = ListNode(0) dummy.next = head while pre.next is not None and pre.next.next is not None: left, right = pre.next, pre.next.next pre.next = right left.next = right.next right.next = left pre = left return dummy.next","link":"/wanderland/2019/06/01/swap-nodes-in-pairs/"},{"title":"Github 上值得关注的资源","text":"Python Programming alive-progressAn animated and smart Progress Bar for python Go Programming go-pryGo 语言互动式的 REPL 环境，可以直接运行 Go 脚本 Vim vim-orgmodeText outlining and task management for Vim based on Emacs’ Org-Mode Git git-flight-rules给使用 Git 的程序员处理各种情况的指南 Docker docker-library/docDocker 官方镜像的文档，可以借鉴官方标准的 Dockerfile 教学 GitHub 上某人总结的各种技巧和经验涉及 Emacs，Linux，各种编程语言","link":"/wanderland/2019/08/26/articles/github/"},{"title":"一些有用的工具以及资源","text":"Linux bootlin搜索和查看 Linux 内核源代码的网站 Go Programming go-pryGo 语言互动式的 REPL 环境，可以直接运行 Go 脚本 JavaScript jsinspectJavaScript 检查重复代码的工具 前端 tesseract.js一个可以完成 N 多语言光学识别的 js 库 testcafe前端 UI 测试框架 DocusaurusFacebook 出品的 Markdown 静态文档网站的建站工具，Docusaurus 2 正在开发中 react-beautiful-dndReact 拖拽组件 majesticJest 测试框架的图形界面 组件库 ui-libraries收集了前端各种 UI 组件库 Semiotic一款 React 的数据可视化框架，很漂亮简洁 图标 ikonate开源的一套 SVG 图标 zwicon 图片 Upsplash免费的高清图片网站 Cool Backgrounds自动生成背景图片的网站 CSS CSS Gradient提供定制化的 CSS Gradient 样式 css-doodle一款 Web 组件使用 CSS 来制作绚烂的 pattern Mac App Winds一款开源的 RSS 阅读和 Podcast APP VSCode Plugin Python Preview一款可以在编辑器中可视化 Python 执行过程的插件 TabNine基于深度学习的代码补全工具 其他 fusuma可以将 Markdown 文件转换成幻灯片，功能很强大 mkcert生成本地 HTTPS 加密证书的工具 refined-github为 Github 增加很多功能的浏览器扩展 nodeppt将 Markdown 文档转换成幻灯片，在浏览器中掩饰 termtosvg将命令行操作录制为 svg 动画 cartoonify使用摄像头，树莓派和热敏打印机拍出卡通图片 OctoLinkerChrome 插件，可以将 Github 的代码中的模块加载语句变成链接直接跳转 Toolfx.com网站收集了专供程序员使用的一些在线工具 Pock一款可以将 Mac 的 Dock 栏搬到 Touchbar Developer Jobs in Japan该网站收集了日本的软件工程师的职位机会 Rico’s cheatsheetsCheatsheet 大全 Nand Game网页游戏，通过组合虚拟电路，组装出一台计算机 diffconflictsGit 的两方合并算法 stackshare.io收集各个公司使用的技术栈，可以用来查看自己喜欢的公司使用的技术栈 Dadroit JSON Viewer一款浏览大型 JSON 数据文件的桌面软件 Hexo theme cold stoneHexo 主题","link":"/wanderland/2019/06/02/articles/tools/"},{"title":"一些有趣的文章","text":"原理 只有 13 台 DNS 根域名服务器的原因此文解释了为什么 DNS 根域名服务器只有 13 个 IP 的原因 如何用 Python 实现一个简单的 JSON 解析器此文描述了使用 Python 如何实现一个简单的 JSON Parser，主要体现在词法分析 (lexical) 和语法分析 (syntactic) 两个步骤 Python Pragmatic UnicodeUnicode in Python2 and Python3 Unicode &amp; Character Encodings in Python: A Painless Guide解释了什么是 Character Encoding 以及 Unicode。全面介绍了 Python3 中 Unicode encoding 和 decoding Python PattensPython 语言中的设计模式 Things you’re probably not using in Python 3 - but should介绍了 Python 3 中的一些 features So you want to contribute to CPython: gather here!作者介绍了自己如何开始为 CPython 贡献代码的经历 Faster Docker builds with pipenv, poetry, or pip-tools How to Easily Use a Progress Bar in Python作者列举了一些比较受欢迎的进度条 Library A Visual Intro to NumPy and Data RepresentationNumpy 的可视化介绍 The state of type hints in PythonPython 类型系统的现状，比较详细 TimSortPython 的默认排序算法 TimSort 的基本原理 Avoiding Webscraping Throttling Using Python and Tor as a Proxy使用 Python 和 Tor 来做爬虫，避免被反爬 7 Habits to Improve the Performance of Python Programs提供了一些提升 Python 性能的建议 Linux Linux: a Portable Operating System大神 Linus Torvalds 当年的硕士毕业论文，介绍 Linux 系统如何适配不同的硬件架构 Unix as IDE展示如何用 Unix 命令行工具完成 IDE 的功能。中文翻译 How to write idempotent Bash scripts如何来编写幂等 Bash 脚本 前端 如何编写深色主题的 CSS本文介绍了 Yandex Mail 团队如何使用 CSS 代码实现 APP 上的深色主题 How to Implement an HTTP Request Library with Axios本文分析 axios 的内部设计 设计 非设计师需要知道的设计原则本文介绍了四个简单基本的设计原则给非设计人员 测试 testcafe 教程本文介绍了前端 UI 测试框架 testcafe Web HTTP Security HeadersHTTP 头信息中与安全相关的字段 从图片优化说起如何使用 Node.js 进行各种图片操作，优化 Web 图片体验 Network The Story of the PING Program本文是我们常用的 PING 的命令的作者撰写的是如何写出这个工具的 Kubernetes A Tutorial Introduction to KubernetesKubernetes 上手入门教程 其他 Why We’re Switching to gRPC本文介绍了为什么作者的团队选择了 gRPC 作为服务间的通信方式 20 lines of code that will beat A/B testing every time本文作者提出了一种超越 A/B 测试的算法，并且很容易来实现 Router Hacking How to bypass “slider CAPTCHA” with JS and Puppeteer本文展示如何使用 Puppeteer 的自动化脚本破解滑块验证","link":"/wanderland/2019/06/02/articles/articles/"},{"title":"Convert Sorted List to Binary Search Tree","text":"ProblemGiven a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: 123456789Given the sorted linked list: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \\ -3 9 / / -10 5 SolutionIt is relatively easy to solve this problem recursively (Depth-first). The idea is to find the middle node in the linked list as the root of the binary search tree, and do the same process for both left and right parts of the linked list. Please note that we need to disconnect the left and right portions of the list after we find the middle node. 12345678910111213141516171819202122232425262728293031323334353637383940class ListNode: def __init__(self, x): self.val = x self.next = Noneclass TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Nonedef sorted_list_to_bst(head: ListNode) -&gt; TreeNode: if head is None: return middle = find_middle_node(head) root = TreeNode(middle.val) root.left = sorted_list_to_bst(head) root.right = sorted_list_to_bst(middle.next) return rootdef find_middle_node(head: ListNode) -&gt; ListNode: prev = None slow = fast = head while fast and fast.next: prev = slow slow = slow.next fast = fast.next.next # disconnect left and right parts if prev: prev.next = None return slow","link":"/wanderland/2019/09/14/leetcode/convert-sorted-list-to-binary-search-tree/"},{"title":"教程","text":"Algorithms Data Structures Reference Data Structures and Algorithms An Integer Formula for Fibonacci Numbers Docker Dockerizing a React AppReact 应用的 Docker 化。文中介绍了如何将 React 应用打包成生产环境可用的容器 Intro Guide to Dockerfile Best Practices介绍编写 Dockerfile 的最佳实践, 节省构建时间、image 大小，增加可维护性、安全性和可重复性 Python 如何用 Python 实现一个简单的 JSON 解析器此文描述了使用 Python 如何实现一个简单的 JSON Parser，主要体现在词法分析 (lexical) 和语法分析 (syntactic) 两个步骤 Python PattensPython 语言中的设计模式 Golang Learning Golang from zero to hero Go 101 前端 How to Use SVG Patterns as Backgrounds教你如何手写一个 SVG 文件作为网页的背景图案 CSS 如何编写深色主题的 CSS本文介绍了 Yandex Mail 团队如何使用 CSS 代码实现 APP 上的深色主题 如何写网页的社交媒体分享功能 Unicode 字符与 CSS 背景本文介绍了使用 Unicode 字符来做 CSS 背景。续篇 Design 非设计师需要知道的设计原则本文介绍了四个简单基本的设计原则给非设计人员 测试 testcafe 教程本文介绍了前端 UI 测试框架 testcafe 架构 网站架构101介绍大型网站架构的基本知识 Serverless Best PracticesServerless 架构应该注意的问题 其他 How does a CPU work Certificates for localhost本文介绍了如何为 localhost 生成证书 SQL Style GuideSQL 的风格指南 Learn LaTeX in 30 minsLaTeX 的快速入门教程","link":"/wanderland/2019/06/16/articles/tutorials/"},{"title":"学习资源","text":"算法 Data Structure Visualizations 设计模式 Design Pattens for Humans Python Pattens 系统设计 Grokking the System Design Interview Python Python Tips通俗易懂的 Python 教程 Python Resources一位在美国上学的巴基斯坦小哥的 Blog 中收集的资源，这位小哥自己撰写了 Python Tips Python Parallel Programming CookbookPython Parallel Programming Cookbook 的中文翻译，仓库中也包含英文原版 Go Programming High Performance Go Workshop Go 101 Advanced Go Programming BookGo 语言高级编程开源图书 Golangbot 系列教程翻译Golangbog 是国外开发者写的 Go 语言的初级教程 Linux pure bash bible 前端 RMind作者基于 React Hooks 和 flex 布局实现了思维导图，可以作为学习资源 Acceptance Test Driven Development with React一位中国的开发者撰写的关于前端测试方面的书 Node Best Practices 语言 Crafting Interpreters如何写一个解释器，其实就是如何自己设计并实现一门语言 其它 Emulator 101从零开始讲解如何写一个 8080 处理器的模拟器 Processor Design使用通俗语言讲解 CPU 原理","link":"/wanderland/2019/04/14/articles/learn-resource/"},{"title":"Partition List","text":"ProblemGiven a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original order of the nodes in each of the two partitions. Example: 12Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 SolutionThe strategy to solve this problem is kind of straightforward: we can start with two pointers, one is going to knit all nodes less than x and another with the rest. We finish the problem by connecting the two lists together. The time complexity is O(n) and space complexity is O(1). 1234567891011121314151617181920212223class ListNode: def __init__(self, x): self.val = x self.next = Nonedef partition_list(head: ListNode, x: int) -&gt; ListNode: before_dummy = before = ListNode(0) after_dummy = after = ListNode(0) while head: if head.val &lt; x: before.next = head before = before.next else: after.next = head after = after.next head = head.next after.next = None # DON'T forget to cut off the tail's next before.next = after_dummy.next return before.dummy","link":"/wanderland/2019/09/11/leetcode/partition-list/"},{"title":"Remove Duplicates from Sorted List II","text":"ProblemGiven a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Example 1: 12Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5Output: 1-&gt;2-&gt;5 Example 2: 12Input: 1-&gt;1-&gt;1-&gt;2-&gt;3Output: 2-&gt;3 SolutionSimilar to the problem in leetcode 82, we compare current and next node. But this time we need a prev reference in order to connect the next node with distinct value. 12345678910111213141516171819202122232425class ListNode: def __init__(self, x): self.val = x self.next = Nonedef delete_duplicates(head: ListNode) -&gt; ListNode: if head is None or head.next is None: return head prev = dummy = ListNode(0) dummy.next = head while head and head.next: if head.val == head.next.val: while head and head.next and head.val == head.next.val: head = head.next prev.next = head.next else: prev = head head = head.next return dummy.next","link":"/wanderland/2019/09/10/leetcode/remove-duplicates-from-sorted-list-ii/"},{"title":"Reverse Linked List II","text":"ProblemReverse a linked list from position m to n. Do it in one-pass. Note: 1 ≤ m ≤ n ≤ length of list. Example: 12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL SolutionsTo reverse part of the linked list, we need to reach the starting node in the reverse zone, and then do the regular reverse action. The last thing we need to do is connecting the intact part with the reversed section. The code clearly shows how. 1234567891011121314151617181920212223242526272829class ListNode: def __init__(self, x): self.val = x self.next = Nonedef reverse_between(head: ListNode, m: int, n: int) -&gt; ListNode: prev = dummy = ListNode(0) dummy.next = head for _ in range(1, m): prev = prev.next m_prev = prev # the last node before the reverse zone m_curr = n_curr = prev.next # the first node in reverse zone n_post = n_curr.next # the first node after the reverse zone for _ range(m, n): temp = n_post.next n_post.next = n_curr n_curr = n_post n_post = temp # 1 -&gt; 2 &lt;-&gt; 3 &lt;- 4 5 # | | | | # m_prev m_curr n_curr n_post m_prev = n_curr m_curr.next = n_post return dummny.next","link":"/wanderland/2019/09/12/leetcode/reverse-linked-list-ii/"},{"title":"Remove Duplicates from Sorted List","text":"ProblemGiven a sorted linked list, delete all duplicates such that each element appear only once. Example 1: 12Input: 1-&gt;1-&gt;2Output: 1-&gt;2 Example 2: 12Input: 1-&gt;1-&gt;2-&gt;3-&gt;3Output: 1-&gt;2-&gt;3 SolutionTo solve this problem, we compare current and next node. If two adjacent nodes’ values are same, the next node is skipped. The solution is relatively intuitive. 123456789101112131415161718class ListNode: def __init__(self, x): self.val = x self.next = Nonedef delete_duplicates(head: ListNode) -&gt; ListNode: if head is None: return curr = head while curr and curr.next: if curr.val == curr.next.val: curr.next = curr.next.next else: curr = curr.next return head","link":"/wanderland/2019/09/09/leetcode/remove-duplicates-from-sorted-list/"},{"title":"Rotate List","text":"ProblemGiven a linked list, rotate the list to the right by k places, where k is non-negative. Example 1: 12345Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULLExplanation:rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULLrotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL Example 2: 1234567Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4Output: 2-&gt;0-&gt;1-&gt;NULLExplanation:rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULLrotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULLrotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULLrotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL SolutionsThe key to solve this problem is making a cyclic linked list by connecting the tail with the head, and then searching for the new head node after the rotate happens. The code is not complex and relatively self explanatory. 12345678910111213141516171819202122232425class ListNode: def ___init___(self, x): self.val = x self.next = Nonedef rotate_right(head: ListNode, k: int) -&gt; ListNode: if head is None: return curr, length = head, 1 while curr.next: curr = curr.next length += 1 curr.next = head # make a loop tail = head for _ in range(length - k % length - 1): tail = tail.next res = tail.next # the returned head node tail.next = None return res","link":"/wanderland/2019/09/08/leetcode/rotate-list/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","link":"/wanderland/tags/LeetCode/"},{"name":"Array","slug":"Array","link":"/wanderland/tags/Array/"},{"name":"Two Pointers","slug":"Two-Pointers","link":"/wanderland/tags/Two-Pointers/"},{"name":"Binary Search","slug":"Binary-Search","link":"/wanderland/tags/Binary-Search/"},{"name":"Hash Table","slug":"Hash-Table","link":"/wanderland/tags/Hash-Table/"},{"name":"Tree","slug":"Tree","link":"/wanderland/tags/Tree/"},{"name":"Linked List","slug":"Linked-List","link":"/wanderland/tags/Linked-List/"},{"name":"Sentinel","slug":"Sentinel","link":"/wanderland/tags/Sentinel/"},{"name":"Math","slug":"Math","link":"/wanderland/tags/Math/"},{"name":"Divide and Conquer","slug":"Divide-and-Conquer","link":"/wanderland/tags/Divide-and-Conquer/"},{"name":"Heap","slug":"Heap","link":"/wanderland/tags/Heap/"},{"name":"Big Manipulation","slug":"Big-Manipulation","link":"/wanderland/tags/Big-Manipulation/"},{"name":"Recursion","slug":"Recursion","link":"/wanderland/tags/Recursion/"},{"name":"Algorithms","slug":"Algorithms","link":"/wanderland/tags/Algorithms/"},{"name":"Sorting","slug":"Sorting","link":"/wanderland/tags/Sorting/"},{"name":"Github","slug":"Github","link":"/wanderland/tags/Github/"},{"name":"Tools","slug":"Tools","link":"/wanderland/tags/Tools/"},{"name":"Article","slug":"Article","link":"/wanderland/tags/Article/"},{"name":"Depth-first Search","slug":"Depth-first-Search","link":"/wanderland/tags/Depth-first-Search/"},{"name":"Tutorial","slug":"Tutorial","link":"/wanderland/tags/Tutorial/"},{"name":"Learn","slug":"Learn","link":"/wanderland/tags/Learn/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","link":"/wanderland/categories/LeetCode/"},{"name":"Collection","slug":"Collection","link":"/wanderland/categories/Collection/"}]}